From f6540119d5b064361ffcb370373794932f97bfdd Mon Sep 17 00:00:00 2001
From: Dom Cobley <dc4@broadcom.com>
Date: Tue, 9 Jul 2013 09:26:26 -0400
Subject: [PATCH 01/14] Allow applications to set next resource handle

This patch adds provisions in userland to
let apps callers set the next rendereing dispmanx resource.
It's useful for implementing, say, a buffer carousel.
---
 interface/khronos/common/khrn_client_rpc.h |  2 ++
 interface/khronos/common/khrn_int_ids.h    |  2 ++
 interface/khronos/egl/egl_client.c         | 30 +++++++++++++++++++++++++++---
 interface/khronos/egl/egl_client_surface.c | 24 +++++++++++++++++++++++-
 interface/khronos/egl/egl_client_surface.h |  3 ++-
 interface/khronos/egl/egl_int_impl.h       |  5 +++--
 6 files changed, 59 insertions(+), 7 deletions(-)

diff --git a/interface/khronos/common/khrn_client_rpc.h b/interface/khronos/common/khrn_client_rpc.h
index dc4351d..10ea060 100644
--- a/interface/khronos/common/khrn_client_rpc.h
+++ b/interface/khronos/common/khrn_client_rpc.h
@@ -685,6 +685,7 @@ static INLINE void rpc_call12_out_ctrl(CLIENT_THREAD_STATE_T *thread,uint32_t id
 static INLINE void rpc_call13_out_ctrl(CLIENT_THREAD_STATE_T *thread,uint32_t id, uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, uint32_t p8, uint32_t p9, uint32_t p10, uint32_t p11, void *out)               { rpc_begin(thread); RPC_CALL(thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);      rpc_recv(thread, out, NULL, (RPC_RECV_FLAG_T)(RPC_RECV_FLAG_CTRL | RPC_RECV_FLAG_LEN)); rpc_end(thread); }
 static INLINE void rpc_call14_out_ctrl(CLIENT_THREAD_STATE_T *thread,uint32_t id, uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, uint32_t p8, uint32_t p9, uint32_t p10, uint32_t p11, uint32_t p12, void *out) { rpc_begin(thread); RPC_CALL(thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); rpc_recv(thread, out, NULL, (RPC_RECV_FLAG_T)(RPC_RECV_FLAG_CTRL | RPC_RECV_FLAG_LEN)); rpc_end(thread); }
 static INLINE void rpc_call15_out_ctrl(CLIENT_THREAD_STATE_T *thread,uint32_t id, uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, uint32_t p8, uint32_t p9, uint32_t p10, uint32_t p11, uint32_t p12, uint32_t p13, void *out) { rpc_begin(thread); RPC_CALL(thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); rpc_recv(thread, out, NULL, (RPC_RECV_FLAG_T)(RPC_RECV_FLAG_CTRL | RPC_RECV_FLAG_LEN)); rpc_end(thread); }
+static INLINE void rpc_call16_out_ctrl(CLIENT_THREAD_STATE_T *thread,uint32_t id, uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, uint32_t p8, uint32_t p9, uint32_t p10, uint32_t p11, uint32_t p12, uint32_t p13, uint32_t p14, void *out) { rpc_begin(thread); RPC_CALL(thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); rpc_recv(thread, out, NULL, (RPC_RECV_FLAG_T)(RPC_RECV_FLAG_CTRL | RPC_RECV_FLAG_LEN)); rpc_end(thread); }
 #endif
 
 #define RPC_CALL1_OUT_CTRL(fn, thread, id, out)                                               rpc_call1_out_ctrl(thread, id, out)
@@ -702,6 +703,7 @@ static INLINE void rpc_call15_out_ctrl(CLIENT_THREAD_STATE_T *thread,uint32_t id
 #define RPC_CALL13_OUT_CTRL(fn, thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, out)      rpc_call13_out_ctrl(thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, out)
 #define RPC_CALL14_OUT_CTRL(fn, thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, out) rpc_call14_out_ctrl(thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, out)
 #define RPC_CALL15_OUT_CTRL(fn, thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, out) rpc_call15_out_ctrl(thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, out)
+#define RPC_CALL16_OUT_CTRL(fn, thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, out) rpc_call16_out_ctrl(thread, id, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, out)
 
 # if !defined(__SYMBIAN32__)  //use functions defined in khrpc.cpp
 static INLINE uint32_t rpc_call1_out_ctrl_res(CLIENT_THREAD_STATE_T *thread,uint32_t id, void *out)                                                                                                                       { uint32_t res; rpc_begin(thread); RPC_CALL(thread, id);                                     res = rpc_recv(thread, out, NULL, (RPC_RECV_FLAG_T)(RPC_RECV_FLAG_RES | RPC_RECV_FLAG_CTRL | RPC_RECV_FLAG_LEN)); rpc_end(thread); return res; }
diff --git a/interface/khronos/common/khrn_int_ids.h b/interface/khronos/common/khrn_int_ids.h
index 8378f4a..ec961e0 100644
--- a/interface/khronos/common/khrn_int_ids.h
+++ b/interface/khronos/common/khrn_int_ids.h
@@ -367,6 +367,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 #define EGLINTCREATESURFACE_ID            0x4000
+#define EGLINTCREATESURFACE_ID_V2         0x4100
 #define EGLINTCREATEGLES11_ID             0x4001
 #define EGLINTCREATEGLES20_ID             0x4002
 #define EGLINTCREATEVG_ID                 0x4003
@@ -377,6 +378,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define EGLINTMAKECURRENT_ID              0x4008
 #define EGLINTFLUSHANDWAIT_ID             0x4009
 #define EGLINTSWAPBUFFERS_ID              0x400a
+#define EGLINTSWAPBUFFERS_ID_V2           0x410a
 #define EGLINTSELECTMIPMAP_ID             0x400b
 #define EGLINTFLUSH_ID                    0x400c
 #define EGLINTGETCOLORDATA_ID             0x400d
diff --git a/interface/khronos/egl/egl_client.c b/interface/khronos/egl/egl_client.c
index 9d617c8..b8bb374 100644
--- a/interface/khronos/egl/egl_client.c
+++ b/interface/khronos/egl/egl_client.c
@@ -162,6 +162,17 @@ static void egl_current_release(CLIENT_PROCESS_STATE_T *process, EGL_CURRENT_T *
 void egl_gl_flush_callback(bool wait);
 void egl_vg_flush_callback(bool wait);
 
+#include "interface/vmcs_host/vc_dispmanx_types.h"
+/**HACKHACK - give us the ability to inject a DispmanX 
+ * resource handle into the CreateWindowSurface and 
+ * SwapBuffers calls */ 
+static DISPMANX_RESOURCE_HANDLE_T next_resource_handle;
+
+EGLAPI EGLBoolean EGLAPIENTRY eglSetNextResourceHandle(DISPMANX_RESOURCE_HANDLE_T handle)
+{
+   next_resource_handle = handle;
+}
+
 /*
 TODO: do an RPC call to make sure the Khronos vll is loaded (and that it stays loaded until eglTerminate)
 Also affects global image (and possibly others?)
@@ -644,7 +655,8 @@ EGLAPI EGLSurface EGLAPIENTRY eglCreateWindowSurface(EGLDisplay dpy, EGLConfig c
                                 false,
                                 EGL_NO_TEXTURE,
                                 EGL_NO_TEXTURE,
-                                0, 0);
+                                0, 0,
+                                next_resource_handle);
 
                if (surface) {
                   if (khrn_pointer_map_insert(&process->surfaces, process->next_surface, surface)) {
@@ -889,7 +901,7 @@ EGLAPI EGLSurface EGLAPIENTRY eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig
                              mipmap_texture,
                              texture_format,
                              texture_target,
-                             0, 0);
+                             0, 0, 0);
 
             if (surface) {
                if (khrn_pointer_map_insert(&process->surfaces, process->next_surface, surface)) {
@@ -1031,7 +1043,7 @@ EGLAPI EGLSurface EGLAPIENTRY eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig c
                                    false,
                                    EGL_NO_TEXTURE,
                                    EGL_NO_TEXTURE,
-                                   pixmap, ((server_handle[0] == 0) && (server_handle[1] == (uint32_t)(-1))) ? NULL : server_handle);
+                                   pixmap, ((server_handle[0] == 0) && (server_handle[1] == (uint32_t)(-1))) ? NULL : server_handle, 0);
 
                      if (surface) {
                         if (khrn_pointer_map_insert(&process->surfaces, process->next_surface, surface)) {
@@ -2303,6 +2315,18 @@ EGLAPI EGLBoolean EGLAPIENTRY eglSwapBuffers(EGLDisplay dpy, EGLSurface surf)
 
                vcos_log_trace("eglSwapBuffers server call");
 
+               if (next_resource_handle)
+               RPC_CALL7(eglIntSwapBuffers_impl,
+                     thread,
+                     EGLINTSWAPBUFFERS_ID_V2,
+                     RPC_UINT(surface->serverbuffer),
+                     RPC_UINT(surface->width),
+                     RPC_UINT(surface->height),
+                     RPC_UINT(surface->internal_handle),
+                     RPC_UINT(surface->swap_behavior == EGL_BUFFER_PRESERVED ? 1 : 0),
+                     RPC_UINT(khrn_platform_get_window_position(surface->win)),
+                     RPC_INT(next_resource_handle));
+               else
                RPC_CALL6(eglIntSwapBuffers_impl,
                      thread,
                      EGLINTSWAPBUFFERS_ID,
diff --git a/interface/khronos/egl/egl_client_surface.c b/interface/khronos/egl/egl_client_surface.c
index 6846dfa..128325e 100644
--- a/interface/khronos/egl/egl_client_surface.c
+++ b/interface/khronos/egl/egl_client_surface.c
@@ -314,7 +314,8 @@ EGL_SURFACE_T *egl_surface_create(
    EGLenum texture_format,
    EGLenum texture_target,
    EGLNativePixmapType pixmap,
-   const uint32_t *pixmap_server_handle)
+   const uint32_t *pixmap_server_handle,
+   DISPMANX_RESOURCE_HANDLE_T next_resource_handle)
 {
    KHRN_IMAGE_FORMAT_T color;
    KHRN_IMAGE_FORMAT_T depth;
@@ -473,6 +474,27 @@ EGL_SURFACE_T *egl_surface_create(
 #endif
          uint32_t results[3];
 
+         if (next_resource_handle)
+         RPC_CALL16_OUT_CTRL(eglIntCreateSurface_impl,
+                             thread,
+                             EGLINTCREATESURFACE_ID_V2,
+                             RPC_UINT(serverwin),
+                             RPC_UINT(buffers),
+                             RPC_UINT(width),
+                             RPC_UINT(height),
+                             RPC_UINT(color),
+                             RPC_UINT(depth),
+                             RPC_UINT(mask),
+                             RPC_UINT(multi),
+                             RPC_UINT(largest_pbuffer),
+                             RPC_UINT(mipmap_texture),
+                             RPC_UINT(config_depth_bits),
+                             RPC_UINT(config_stencil_bits),
+                             RPC_UINT(sem_name),
+                             RPC_UINT(type),
+                             RPC_INT(next_resource_handle),
+                             results);
+         else
          RPC_CALL15_OUT_CTRL(eglIntCreateSurface_impl,
                              thread,
                              EGLINTCREATESURFACE_ID,
diff --git a/interface/khronos/egl/egl_client_surface.h b/interface/khronos/egl/egl_client_surface.h
index c99d44c..b5bf70a 100644
--- a/interface/khronos/egl/egl_client_surface.h
+++ b/interface/khronos/egl/egl_client_surface.h
@@ -322,7 +322,8 @@ extern EGL_SURFACE_T *egl_surface_create(
    EGLenum texture_format,
    EGLenum texture_target,
    EGLNativePixmapType pixmap,
-   const uint32_t *pixmap_server_handle);
+   const uint32_t *pixmap_server_handle,
+   DISPMANX_RESOURCE_HANDLE_T next_resource_handle);
 extern EGL_SURFACE_T *egl_surface_from_vg_image(
    VGImage vg_handle,
    EGLSurface name,
diff --git a/interface/khronos/egl/egl_int_impl.h b/interface/khronos/egl/egl_int_impl.h
index 8a5734c..51b3580 100644
--- a/interface/khronos/egl/egl_int_impl.h
+++ b/interface/khronos/egl/egl_int_impl.h
@@ -56,7 +56,8 @@ FN(int, eglIntCreateSurface_impl, (
    uint32_t config_stencil_bits,
    uint32_t sem,
    uint32_t type,
-   uint32_t *results))
+   uint32_t *results,
+   DISPMANX_RESOURCE_HANDLE_T next_resource_handle))
 
 FN(int, eglIntCreatePbufferFromVGImage_impl, (
    VGImage vg_handle,
@@ -110,7 +111,7 @@ FN(void, eglIntMakeCurrent_impl, (uint32_t pid_0, uint32_t pid_1, uint32_t glver
 FN(int, eglIntFlushAndWait_impl, (uint32_t flushgl, uint32_t flushvg))
 FN(void, eglIntFlush_impl, (uint32_t flushgl, uint32_t flushvg))
 
-FN(void, eglIntSwapBuffers_impl, (EGL_SURFACE_ID_T s, uint32_t width, uint32_t height, uint32_t handle, uint32_t preserve, uint32_t position))
+FN(void, eglIntSwapBuffers_impl, (EGL_SURFACE_ID_T s, uint32_t width, uint32_t height, uint32_t handle, uint32_t preserve, uint32_t position, DISPMANX_RESOURCE_HANDLE_T new_back_buffer))
 FN(void, eglIntSelectMipmap_impl, (EGL_SURFACE_ID_T s, int level))
 
 FN(void, eglIntGetColorData_impl, (EGL_SURFACE_ID_T s, KHRN_IMAGE_FORMAT_T format, uint32_t width, uint32_t height, int32_t stride, uint32_t y_offset, void *data))

From 5f9e011a6c15b3a05b3be412d7ba5c1077ececf1 Mon Sep 17 00:00:00 2001
From: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date: Tue, 1 Oct 2013 13:19:20 +0200
Subject: [PATCH 02/14] wayland: Add support for the Wayland winsys

* Adds EGL_WL_bind_wayland_display extension
* Adds wayland-egl library
* Adds wl_dispmanx_buffer protocol extension

TODO: Check that platform_get_dimensions() returning swapchain_count == 1 is correct

TODO: Remove the requirement of passing a valid DispmanX element handle to
the SwapBuffers and CreateSurface RPC calls. This will remove the need to open
a DispmanX display from the clients.

TODO: wl_dispmanx_server_buffer should probably be defined in a
private header that can be included from EGL and vc_* instead of in
vc_vchi_dispmanx.h
---
 .gitignore                                         |   2 +
 CMakeLists.txt                                     |  11 +
 README.md                                          |   4 +
 buildme                                            |  10 +-
 .../linux/apps/raspicam/CMakeLists.txt             |   2 +-
 interface/khronos/CMakeLists.txt                   |  53 ++++-
 interface/khronos/common/khrn_client.c             |  15 ++
 interface/khronos/common/khrn_client.h             |  10 +
 interface/khronos/common/khrn_client_mangle.h      |   3 +
 interface/khronos/common/khrn_client_platform.h    |   8 +
 interface/khronos/common/khrn_client_unmangle.h    |   3 +
 .../common/linux/khrn_client_platform_linux.c      | 115 ++++++++--
 interface/khronos/common/linux/khrn_wayland.c      | 215 ++++++++++++++++++
 interface/khronos/common/linux/khrn_wayland.h      |  33 +++
 interface/khronos/egl/egl_client.c                 |  92 +++++---
 interface/khronos/egl/egl_client_get_proc.c        |  11 +
 interface/khronos/egl/egl_client_surface.c         |  42 +++-
 interface/khronos/egl/egl_client_surface.h         |  38 +++-
 interface/khronos/egl/egl_int_impl.h               |   2 +-
 interface/khronos/ext/egl_wayland.c                | 246 +++++++++++++++++++++
 interface/khronos/include/EGL/eglext.h             |  23 ++
 interface/khronos/wayland-egl/wayland-egl-priv.h   |  53 +++++
 interface/khronos/wayland-egl/wayland-egl.c        |  59 +++++
 interface/khronos/wayland-egl/wayland-egl.pc.in    |  10 +
 interface/vmcs_host/CMakeLists.txt                 |  21 +-
 interface/vmcs_host/vc_dispmanx.h                  |  10 +
 interface/vmcs_host/vc_vchi_dispmanx.c             |  42 ++++
 interface/vmcs_host/vc_vchi_dispmanx.h             |  15 ++
 interface/wayland/dispmanx.xml                     | 123 +++++++++++
 makefiles/cmake/Wayland.cmake                      |  72 ++++++
 30 files changed, 1286 insertions(+), 57 deletions(-)
 create mode 100644 interface/khronos/common/linux/khrn_wayland.c
 create mode 100644 interface/khronos/common/linux/khrn_wayland.h
 create mode 100644 interface/khronos/ext/egl_wayland.c
 create mode 100644 interface/khronos/wayland-egl/wayland-egl-priv.h
 create mode 100644 interface/khronos/wayland-egl/wayland-egl.c
 create mode 100644 interface/khronos/wayland-egl/wayland-egl.pc.in
 create mode 100644 interface/wayland/dispmanx.xml
 create mode 100644 makefiles/cmake/Wayland.cmake

diff --git a/.gitignore b/.gitignore
index 4a88665..5da71a9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,3 +13,5 @@ build/
 *.lai
 *.la
 *.a
+
+*~
diff --git a/CMakeLists.txt b/CMakeLists.txt
index cfc8ae5..673a5ad 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -24,6 +24,17 @@ include(makefiles/cmake/global_settings.cmake)
 include(makefiles/cmake/arm-linux.cmake)
 include(makefiles/cmake/vmcs.cmake)
 
+if (BUILD_WAYLAND)
+   include(makefiles/cmake/Wayland.cmake)
+
+   # Find Wayland libraries
+   find_package(PkgConfig)
+   pkg_check_modules(WAYLAND_CLIENT wayland-client REQUIRED)
+   pkg_check_modules(WAYLAND_SERVER wayland-server REQUIRED)
+
+   set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DBUILD_WAYLAND")
+endif()
+
 enable_language(ASM)
 
 # Global include paths
diff --git a/README.md b/README.md
index 358d2b4..4da4448 100644
--- a/README.md
+++ b/README.md
@@ -4,3 +4,7 @@ EGL, mmal, GLESv2, vcos, openmaxil, vchiq_arm, bcm_host, WFC, OpenVG.
 
 Use buildme to build. It requires cmake to be installed and an arm cross compiler. It is set up to use this one:
 https://github.com/raspberrypi/tools/tree/master/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian
+
+To build support for the Wayland winsys in EGL, execute the buildme script like this:
+
+$ BUILD_WAYLAND=1 ./buildme.
diff --git a/buildme b/buildme
index 1061745..d0e6e54 100755
--- a/buildme
+++ b/buildme
@@ -8,6 +8,10 @@ fi
 
 BUILDSUBDIR=`echo $BUILDTYPE | tr '[A-Z]' '[a-z]'`;
 
+if [ -n "$BUILD_WAYLAND" ]; then
+       WAYLAND_VARS="-DBUILD_WAYLAND=TRUE"
+fi
+
 if [ "armv6l" = `arch` ] || [ "armv7l" = `arch` ]; then
 	# Native compile on the Raspberry Pi
 	mkdir -p build/raspberry/$BUILDSUBDIR
@@ -32,9 +36,13 @@ elif [ "$1" = "--native" ]; then
 	make -j 6 $*
 else
 	# Cross compile on a more capable machine
+	if [ -n "$BUILD_WAYLAND" ]; then
+		# Use wayland-scanner from the build platform
+		WAYLAND_VARS+=" -DWAYLAND_SCANNER_EXECUTABLE:FILEPATH=/usr/bin/wayland-scanner"
+	fi
 	mkdir -p build/arm-linux/$BUILDSUBDIR
 	pushd build/arm-linux/$BUILDSUBDIR
-	cmake -DCMAKE_TOOLCHAIN_FILE=../../../makefiles/cmake/toolchains/arm-linux-gnueabihf.cmake -DCMAKE_BUILD_TYPE=$BUILDTYPE ../../..
+	cmake -DCMAKE_TOOLCHAIN_FILE=../../../makefiles/cmake/toolchains/arm-linux-gnueabihf.cmake -DCMAKE_BUILD_TYPE=$BUILDTYPE $WAYLAND_VARS ../../..
 	make -j 6
 
 	if [ "$1" != "" ]; then
diff --git a/host_applications/linux/apps/raspicam/CMakeLists.txt b/host_applications/linux/apps/raspicam/CMakeLists.txt
index e6aa6b8..69059cb 100644
--- a/host_applications/linux/apps/raspicam/CMakeLists.txt
+++ b/host_applications/linux/apps/raspicam/CMakeLists.txt
@@ -28,7 +28,7 @@ add_executable(raspividyuv  ${COMMON_SOURCES} RaspiVidYUV.c)
 
 set (MMAL_LIBS mmal_core mmal_util mmal_vc_client)
 
-target_link_libraries(raspistill ${MMAL_LIBS} vcos bcm_host brcmGLESv2 brcmEGL m)
+target_link_libraries(raspistill ${MMAL_LIBS} vcos bcm_host brcmGLESv2 brcmEGL m ${WAYLAND_SERVER_LIBRARIES} ${WAYLAND_CLIENT_LIBRARIES})
 target_link_libraries(raspiyuv   ${MMAL_LIBS} vcos bcm_host)
 target_link_libraries(raspivid   ${MMAL_LIBS} vcos bcm_host)
 target_link_libraries(raspividyuv   ${MMAL_LIBS} vcos bcm_host)
diff --git a/interface/khronos/CMakeLists.txt b/interface/khronos/CMakeLists.txt
index 9ad615b..3d3571a 100644
--- a/interface/khronos/CMakeLists.txt
+++ b/interface/khronos/CMakeLists.txt
@@ -6,6 +6,12 @@
 # have quite a few circular dependencies, and so the only way
 # to make it work seems to be to have everything static.
 
+if (BUILD_WAYLAND)
+include_directories(
+   ${WAYLAND_SERVER_INCLUDE_DIRS}
+)
+endif ()
+
 set(EGL_SOURCE
    egl/egl_client_config.c
    egl/egl_client_context.c
@@ -55,12 +61,56 @@ set(CLIENT_SOURCE
    common/khrn_int_hash_asm.s
    common/khrn_client_cache.c)
 
+set(EGL_LIBS
+   khrn_client
+   vchiq_arm
+   vcos
+   bcm_host
+   -lm)
+
+if (BUILD_WAYLAND)
+   set(EGL_SOURCE
+      ${EGL_SOURCE}
+      ext/egl_wayland.c
+      common/linux/khrn_wayland.c)
+
+   set(EGL_LIBS
+      ${EGL_LIBS}
+      wayland-client
+      wayland-server)
+
+   set(WAYLAND_EGL_SOURCE
+      wayland-egl/wayland-egl.c)
+
+   wayland_add_protocol_server(
+       EGL_SOURCE
+       ../../interface/wayland/dispmanx.xml
+       dispmanx
+   )
+
+   wayland_add_protocol_client(
+       EGL_SOURCE
+       ../../interface/wayland/dispmanx.xml
+       dispmanx
+   )
+
+   add_library(wayland-egl ${SHARED} ${WAYLAND_EGL_SOURCE})
+   install(TARGETS wayland-egl DESTINATION lib)
+
+   configure_file ("wayland-egl/wayland-egl.pc.in" "wayland-egl/wayland-egl.pc" @ONLY)
+   install (FILES "${CMAKE_CURRENT_BINARY_DIR}/wayland-egl/wayland-egl.pc"
+            DESTINATION lib/pkgconfig)
+endif ()
+
 add_library(EGL ${SHARED} ${EGL_SOURCE})
 add_library(GLESv2 ${SHARED} ${GLES_SOURCE})
 add_library(OpenVG ${SHARED} ${VG_SOURCE})
 add_library(WFC ${SHARED} ${WFC_SOURCE})
 add_library(khrn_client ${CLIENT_SOURCE})
 
+set_target_properties(EGL PROPERTIES SOVERSION 1 VERSION 1.0.0)
+set_target_properties(GLESv2 PROPERTIES SOVERSION 2 VERSION 2.0.0)
+
 # TODO do we need EGL_static and GLESv2_static now that khrn_static exists?
 add_library(EGL_static STATIC ${EGL_SOURCE})
 add_library(GLESv2_static STATIC ${GLES_SOURCE})
@@ -72,8 +122,7 @@ include_directories (../../host_applications/linux/libs/sm )
 set(VCSM_LIBS vcsm)
 add_definitions(-DKHRONOS_HAVE_VCSM)
 endif()
-
-target_link_libraries(EGL khrn_client vchiq_arm vcos bcm_host ${VCSM_LIBS} -lm)
+target_link_libraries(EGL ${EGL_LIBS} ${VCSM_LIBS})
 target_link_libraries(GLESv2 EGL khrn_client vcos)
 target_link_libraries(WFC EGL)
 target_link_libraries(OpenVG EGL)
diff --git a/interface/khronos/common/khrn_client.c b/interface/khronos/common/khrn_client.c
index ef4babd..d7e798e 100644
--- a/interface/khronos/common/khrn_client.c
+++ b/interface/khronos/common/khrn_client.c
@@ -54,6 +54,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "applications/vmcs/khronos/khronos_server.h"
 #endif
 
+#ifdef BUILD_WAYLAND
+#include "interface/khronos/common/linux/khrn_wayland.h"
+#endif
+
 VCOS_LOG_CAT_T khrn_client_log = VCOS_LOG_INIT("khrn_client", VCOS_LOG_WARN);
 
 /*
@@ -142,6 +146,10 @@ void client_try_unload_server(CLIENT_PROCESS_STATE_T *process)
 bool client_process_state_init(CLIENT_PROCESS_STATE_T *process)
 {
    if (!process->inited) {
+#ifdef BUILD_WAYLAND
+      process->wl_global = NULL;
+#endif
+
       if (!khrn_pointer_map_init(&process->contexts, 64))
          return false;
 
@@ -194,6 +202,13 @@ bool client_process_state_init(CLIENT_PROCESS_STATE_T *process)
       }
 #endif
 
+#ifdef BUILD_WAYLAND
+      struct wl_display *wl_display = khrn_platform_get_wl_display();
+      if (wl_display)
+         if (!init_process_wayland(process))
+            return false;
+#endif
+
       process->inited = true;
    }
 
diff --git a/interface/khronos/common/khrn_client.h b/interface/khronos/common/khrn_client.h
index 804039b..615f7b4 100644
--- a/interface/khronos/common/khrn_client.h
+++ b/interface/khronos/common/khrn_client.h
@@ -310,6 +310,16 @@ struct CLIENT_PROCESS_STATE {
 #ifdef RPC_LIBRARY
    KHRONOS_SERVER_CONNECTION_T khrn_connection;
 #endif
+
+#ifdef BUILD_WAYLAND
+   /* Client-side Wayland state */
+   struct wl_registry *wl_registry;
+   struct wl_dispmanx *wl_dispmanx;
+   struct wl_event_queue *wl_queue;
+
+   /* Compositor-side Wayland state */
+   struct wl_global *wl_global;
+#endif
 };
 
 extern bool client_process_state_init(CLIENT_PROCESS_STATE_T *process);
diff --git a/interface/khronos/common/khrn_client_mangle.h b/interface/khronos/common/khrn_client_mangle.h
index b3c04f4..b7b21c5 100644
--- a/interface/khronos/common/khrn_client_mangle.h
+++ b/interface/khronos/common/khrn_client_mangle.h
@@ -83,6 +83,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define eglReleaseGlobalImageBRCM mangled_eglReleaseGlobalImageBRCM
 #define eglInitGlobalImageBRCM mangled_eglInitGlobalImageBRCM
 #define eglTermGlobalImageBRCM mangled_eglTermGlobalImageBRCM
+#define eglBindWaylandDisplayWL mangled_eglBindWaylandDisplayWL
+#define eglUnbindWaylandDisplayWL mangled_eglUnbindWaylandDisplayWL
+#define eglQueryWaylandBufferWL mangled_eglQueryWaylandBufferWL
 
 /* OpenGL ES 1.1 and 2.0 functions */
 
diff --git a/interface/khronos/common/khrn_client_platform.h b/interface/khronos/common/khrn_client_platform.h
index 1c9da3a..715c67e 100644
--- a/interface/khronos/common/khrn_client_platform.h
+++ b/interface/khronos/common/khrn_client_platform.h
@@ -48,6 +48,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "interface/khronos/common/vcos/khrn_client_platform_filler_vcos.h"
 #endif
 
+#ifdef BUILD_WAYLAND
+#include <wayland-client.h>
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -328,4 +332,8 @@ typedef struct
 
 void *platform_wfc_bounce_thread(void *param);
 
+#ifdef BUILD_WAYLAND
+struct wl_display *khrn_platform_get_wl_display();
+#endif
+
 #endif // KHRN_CLIENT_PLATFORM_H
diff --git a/interface/khronos/common/khrn_client_unmangle.h b/interface/khronos/common/khrn_client_unmangle.h
index 4f3ce49..84f6ec0 100644
--- a/interface/khronos/common/khrn_client_unmangle.h
+++ b/interface/khronos/common/khrn_client_unmangle.h
@@ -83,6 +83,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #undef eglReleaseGlobalImageBRCM
 #undef eglInitGlobalImageBRCM
 #undef eglTermGlobalImageBRCM
+#undef eglBindWaylandDisplayWL
+#undef eglUnbindWaylandDisplayWL
+#undef eglQueryWaylandBufferWL
 
 /* OpenGL ES 1.1 and 2.0 functions */
 
diff --git a/interface/khronos/common/linux/khrn_client_platform_linux.c b/interface/khronos/common/linux/khrn_client_platform_linux.c
index 710d20f..50d60a6 100644
--- a/interface/khronos/common/linux/khrn_client_platform_linux.c
+++ b/interface/khronos/common/linux/khrn_client_platform_linux.c
@@ -37,6 +37,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "X11/Xlib.h"
 #endif
 
+#ifdef BUILD_WAYLAND
+#include <wayland-client.h>
+#include "interface/khronos/wayland-egl/wayland-egl-priv.h"
+#endif
+
 extern VCOS_LOG_CAT_T khrn_client_log;
 
 extern void vc_vchi_khronos_init();
@@ -464,13 +469,36 @@ EGLDisplay khrn_platform_set_display_id(EGLNativeDisplayType display_id)
 	   return EGL_NO_DISPLAY;
 }
 #else
+
+#ifdef BUILD_WAYLAND
+static struct wl_display *hacky_display = NULL;
+#endif
+
 EGLDisplay khrn_platform_set_display_id(EGLNativeDisplayType display_id)
 {
    if (display_id == EGL_DEFAULT_DISPLAY)
       return (EGLDisplay)1;
-   else
-      return EGL_NO_DISPLAY;
+   else {
+#ifdef BUILD_WAYLAND
+      void *first_pointer = *(void **) display_id;
+
+      /* wl_display is a wl_proxy, which is a wl_object.
+       * wl_object's first element points to the interfacetype. */
+      if (first_pointer == &wl_display_interface) {
+         hacky_display = (struct wl_display*)display_id;
+         return (EGLDisplay)1;
+      } else
+#endif
+         return EGL_NO_DISPLAY;
+   }
 }
+
+#ifdef BUILD_WAYLAND
+struct wl_display *khrn_platform_get_wl_display()
+{
+   return hacky_display;
+}
+#endif
 #endif
 
 #ifdef WANT_X
@@ -805,22 +833,81 @@ static EGL_DISPMANX_WINDOW_T *check_default(EGLNativeWindowType win)
 void platform_get_dimensions(EGLDisplay dpy, EGLNativeWindowType win,
       uint32_t *width, uint32_t *height, uint32_t *swapchain_count)
 {
-   EGL_DISPMANX_WINDOW_T *dwin = check_default(win);
-   vcos_assert(dwin);
-   vcos_assert(dwin->width < 1<<16); // sanity check
-   vcos_assert(dwin->height < 1<<16); // sanity check
-   *width = dwin->width;
-   *height = dwin->height;
-   *swapchain_count = 0;
+#ifdef BUILD_WAYLAND
+   if(khrn_platform_get_wl_display()) {
+      struct wl_egl_window *wl_egl_window = (struct wl_egl_window*)win;
+      *width = wl_egl_window->width;
+      *height = wl_egl_window->height;
+      /* This seems to be used for sync'ing with the VC on buffer creation, but
+         we are managing them on the CPU side */
+      *swapchain_count = 1;
+   } else {
+#endif
+      EGL_DISPMANX_WINDOW_T *dwin = check_default(win);
+      vcos_assert(dwin);
+      vcos_assert(dwin->width < 1<<16); // sanity check
+      vcos_assert(dwin->height < 1<<16); // sanity check
+      *width = dwin->width;
+      *height = dwin->height;
+      *swapchain_count = 0;
+#ifdef BUILD_WAYLAND
+   }
+#endif
 }
 
+#ifdef BUILD_WAYLAND
+static DISPMANX_ELEMENT_HANDLE_T create_dummy_element()
+{
+   DISPMANX_DISPLAY_HANDLE_T display = vc_dispmanx_display_open(0);
+   DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
+   DISPMANX_ELEMENT_HANDLE_T element;
+   VC_DISPMANX_ALPHA_T alpha = {DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS, 255, 0};
+   VC_RECT_T src_rect;
+   VC_RECT_T dst_rect;
+
+   src_rect.x = 0;
+   src_rect.y = 0;
+   src_rect.width = 1 << 16;
+   src_rect.height = 1 << 16;
+
+   dst_rect.x = 0;
+   dst_rect.y = 0;
+   dst_rect.width = 1;
+   dst_rect.height = 1;
+
+   element = vc_dispmanx_element_add(update, display, 0/*layer*/, &dst_rect,
+                                     0/*src*/, &src_rect,
+                                     DISPMANX_PROTECTION_NONE, &alpha,
+                                     0/*clamp*/, 0/*transform*/);
+
+   vc_dispmanx_update_submit_sync(update);
+
+   vc_dispmanx_display_close(display);
+
+   return element;
+}
+#endif
+
 uint32_t platform_get_handle(EGLDisplay dpy, EGLNativeWindowType win)
 {
-   EGL_DISPMANX_WINDOW_T *dwin = check_default(win);
-   vcos_assert(dwin);
-   vcos_assert(dwin->width < 1<<16); // sanity check
-   vcos_assert(dwin->height < 1<<16); // sanity check
-   return dwin->element;
+#ifdef BUILD_WAYLAND
+   if(khrn_platform_get_wl_display()) {
+      struct wl_egl_window *wl_egl_window = (struct wl_egl_window*)win;
+
+      if (wl_egl_window->dummy_element == PLATFORM_WIN_NONE)
+         wl_egl_window->dummy_element = create_dummy_element();
+
+      return wl_egl_window->dummy_element;
+   } else {
+#endif
+      EGL_DISPMANX_WINDOW_T *dwin = check_default(win);
+      vcos_assert(dwin);
+      vcos_assert(dwin->width < 1<<16); // sanity check
+      vcos_assert(dwin->height < 1<<16); // sanity check
+      return dwin->element;
+#ifdef BUILD_WAYLAND
+   }
+#endif
 }
 
 #endif
diff --git a/interface/khronos/common/linux/khrn_wayland.c b/interface/khronos/common/linux/khrn_wayland.c
new file mode 100644
index 0000000..0e1b9e7
--- /dev/null
+++ b/interface/khronos/common/linux/khrn_wayland.c
@@ -0,0 +1,215 @@
+/*
+Copyright (c) 2013, Raspberry Pi Foundation
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#define VCOS_LOG_CATEGORY (&khrn_client_log)
+
+#include "interface/khronos/common/linux/khrn_wayland.h"
+#include "interface/khronos/wayland-dispmanx-client-protocol.h"
+#include "interface/khronos/wayland-egl/wayland-egl-priv.h"
+
+extern VCOS_LOG_CAT_T khrn_client_log;
+
+static void handle_dispmanx_format(void *data, struct wl_dispmanx *dispmanx,
+                                   uint32_t format)
+{
+}
+
+static void handle_dispmanx_allocated(void *data, struct wl_dispmanx *dispmanx,
+                                      struct wl_buffer *wl_buffer,
+                                      uint32_t resource_handle)
+{
+    struct wl_dispmanx_client_buffer *buffer = wl_buffer_get_user_data(wl_buffer);
+
+    buffer->pending_allocation = 0;
+    buffer->resource = resource_handle;
+}
+
+static const struct wl_dispmanx_listener dispmanx_listener = {
+    handle_dispmanx_format,
+    handle_dispmanx_allocated,
+};
+
+static void
+sync_callback(void *data, struct wl_callback *callback, uint32_t serial)
+{
+   int *done = data;
+
+   *done = 1;
+
+   wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener sync_listener = {
+   sync_callback
+};
+
+static int
+roundtrip(CLIENT_PROCESS_STATE_T *process)
+{
+   struct wl_display *wl_display = khrn_platform_get_wl_display();
+   struct wl_callback *callback;
+   int done = 0, ret = 0;
+
+   callback = wl_display_sync(wl_display);
+   wl_callback_add_listener(callback, &sync_listener, &done);
+   wl_proxy_set_queue((struct wl_proxy *) callback, process->wl_queue);
+   while (ret != -1 && !done)
+      ret = wl_display_dispatch_queue(wl_display, process->wl_queue);
+
+   if (!done)
+      wl_callback_destroy(callback);
+
+   return ret;
+}
+
+int do_wl_roundtrip()
+{
+   CLIENT_PROCESS_STATE_T *process = CLIENT_GET_PROCESS_STATE();
+   return roundtrip(process);
+}
+
+static void
+registry_handle_global(void *data, struct wl_registry *registry,
+                       uint32_t name, const char *interface, uint32_t version)
+{
+   struct wl_display *wl_display = khrn_platform_get_wl_display();
+   CLIENT_PROCESS_STATE_T *process = (CLIENT_PROCESS_STATE_T *)data;
+
+   if (strcmp(interface, "wl_dispmanx") == 0) {
+      process->wl_dispmanx = wl_registry_bind(registry, name,
+	       &wl_dispmanx_interface, 1);
+
+      wl_proxy_set_queue((struct wl_proxy *) process->wl_dispmanx,
+                         process->wl_queue);
+      wl_dispmanx_add_listener(process->wl_dispmanx, &dispmanx_listener, wl_display);
+      roundtrip(process);
+   }
+}
+
+static void
+registry_handle_global_remove(void *data, struct wl_registry *registry,
+                              uint32_t name)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global,
+	registry_handle_global_remove
+};
+
+int
+init_process_wayland(CLIENT_PROCESS_STATE_T *process)
+{
+    struct wl_display *wl_display = khrn_platform_get_wl_display();
+
+    process->wl_queue = wl_display_create_queue(wl_display);
+    if (!process->wl_queue) {
+        vcos_log_error("wl_display_create_queue failed\n");
+        return false;
+    }
+    wl_display_dispatch_pending(wl_display);
+
+    process->wl_registry = wl_display_get_registry(wl_display);
+    if (!process->wl_registry) {
+        vcos_log_error("wl_display_get_registry failed\n");
+        return false;
+    }
+
+    wl_proxy_set_queue((struct wl_proxy *) process->wl_registry,
+    process->wl_queue);
+
+    wl_registry_add_listener(process->wl_registry, &registry_listener, process);
+
+    if (roundtrip(process) < 0 || process->wl_dispmanx == NULL) {
+        vcos_log_error("failed to get wl_dispmanx\n");
+        return false;
+    }
+
+    return true;
+}
+
+#ifndef ALIGN_UP
+#define ALIGN_UP(x,y)  ((x + (y)-1) & ~((y)-1))
+#endif
+
+static void handle_buffer_release(void *data, struct wl_buffer *buffer_wl)
+{
+   struct wl_dispmanx_client_buffer *wl_dispmanx_client_buffer = data;
+   wl_dispmanx_client_buffer->in_use = 0;
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+   handle_buffer_release
+};
+
+struct wl_dispmanx_client_buffer *
+allocate_wl_buffer(struct wl_egl_window *window, KHRN_IMAGE_FORMAT_T color)
+{
+   CLIENT_PROCESS_STATE_T *process = CLIENT_GET_PROCESS_STATE();
+   struct wl_dispmanx_client_buffer *wl_dispmanx_client_buffer;
+   struct wl_buffer *wl_buffer;
+   uint32_t stride = ALIGN_UP(window->width * 4, 16);
+   uint32_t buffer_height = ALIGN_UP(window->height, 16);
+   enum wl_dispmanx_format color_format;
+   int ret = 0;
+
+   switch (color) {
+   case ABGR_8888:
+      color_format = WL_DISPMANX_FORMAT_ABGR8888;
+      break;
+   case XBGR_8888:
+      color_format = WL_DISPMANX_FORMAT_XBGR8888;
+      break;
+   case RGB_565:
+      color_format = WL_DISPMANX_FORMAT_RGB565;
+      break;
+   default:
+      vcos_log_error("unknown KHRN_IMAGE_FORMAT_T 0x%x\n", color);
+      return NULL;
+   }
+
+   wl_buffer = wl_dispmanx_create_buffer(process->wl_dispmanx, window->width,
+                                         window->height, stride, buffer_height,
+                                         color_format);
+   if (wl_buffer == NULL)
+      return NULL;
+
+   wl_dispmanx_client_buffer = calloc(1, sizeof(struct wl_dispmanx_client_buffer));
+   wl_dispmanx_client_buffer->wl_buffer = wl_buffer;
+   wl_dispmanx_client_buffer->in_use = 0;
+   wl_dispmanx_client_buffer->pending_allocation = 1;
+   wl_dispmanx_client_buffer->width = window->width;
+   wl_dispmanx_client_buffer->height = window->height;
+
+   wl_proxy_set_queue((struct wl_proxy *) wl_buffer, process->wl_queue);
+   wl_buffer_add_listener(wl_buffer, &buffer_listener, wl_dispmanx_client_buffer);
+
+   while (ret != -1 && wl_dispmanx_client_buffer->pending_allocation)
+      ret = do_wl_roundtrip();
+
+   return wl_dispmanx_client_buffer;
+}
diff --git a/interface/khronos/common/linux/khrn_wayland.h b/interface/khronos/common/linux/khrn_wayland.h
new file mode 100644
index 0000000..b9bf08c
--- /dev/null
+++ b/interface/khronos/common/linux/khrn_wayland.h
@@ -0,0 +1,33 @@
+/*
+Copyright (c) 2013, Raspberry Pi Foundation
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "interface/khronos/common/khrn_client.h"
+
+int init_process_wayland(CLIENT_PROCESS_STATE_T *process);
+int do_wl_roundtrip();
+
+struct wl_dispmanx_client_buffer *allocate_wl_buffer(struct wl_egl_window *window, KHRN_IMAGE_FORMAT_T color);
diff --git a/interface/khronos/egl/egl_client.c b/interface/khronos/egl/egl_client.c
index b8bb374..03fe67b 100644
--- a/interface/khronos/egl/egl_client.c
+++ b/interface/khronos/egl/egl_client.c
@@ -153,6 +153,10 @@ by an attribute value"
 #include <stdlib.h>
 #include <string.h>
 
+#ifdef BUILD_WAYLAND
+#include "interface/khronos/wayland-egl/wayland-egl-priv.h"
+#include "interface/khronos/common/linux/khrn_wayland.h"
+#endif
 
 #include "interface/khronos/egl/egl_client_cr.c"
 
@@ -162,17 +166,6 @@ static void egl_current_release(CLIENT_PROCESS_STATE_T *process, EGL_CURRENT_T *
 void egl_gl_flush_callback(bool wait);
 void egl_vg_flush_callback(bool wait);
 
-#include "interface/vmcs_host/vc_dispmanx_types.h"
-/**HACKHACK - give us the ability to inject a DispmanX 
- * resource handle into the CreateWindowSurface and 
- * SwapBuffers calls */ 
-static DISPMANX_RESOURCE_HANDLE_T next_resource_handle;
-
-EGLAPI EGLBoolean EGLAPIENTRY eglSetNextResourceHandle(DISPMANX_RESOURCE_HANDLE_T handle)
-{
-   next_resource_handle = handle;
-}
-
 /*
 TODO: do an RPC call to make sure the Khronos vll is loaded (and that it stays loaded until eglTerminate)
 Also affects global image (and possibly others?)
@@ -451,6 +444,9 @@ EGLAPI const char EGLAPIENTRY * eglQueryString(EGLDisplay dpy, EGLint name)
             "EGL_KHR_fence_sync "
 #endif
 #endif
+#if EGL_WL_bind_wayland_display
+            "EGL_WL_bind_wayland_display "
+#endif
             ;
          break;
       case EGL_VENDOR:
@@ -655,8 +651,7 @@ EGLAPI EGLSurface EGLAPIENTRY eglCreateWindowSurface(EGLDisplay dpy, EGLConfig c
                                 false,
                                 EGL_NO_TEXTURE,
                                 EGL_NO_TEXTURE,
-                                0, 0,
-                                next_resource_handle);
+                                0, 0);
 
                if (surface) {
                   if (khrn_pointer_map_insert(&process->surfaces, process->next_surface, surface)) {
@@ -901,7 +896,7 @@ EGLAPI EGLSurface EGLAPIENTRY eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig
                              mipmap_texture,
                              texture_format,
                              texture_target,
-                             0, 0, 0);
+                             0, 0);
 
             if (surface) {
                if (khrn_pointer_map_insert(&process->surfaces, process->next_surface, surface)) {
@@ -1043,7 +1038,7 @@ EGLAPI EGLSurface EGLAPIENTRY eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig c
                                    false,
                                    EGL_NO_TEXTURE,
                                    EGL_NO_TEXTURE,
-                                   pixmap, ((server_handle[0] == 0) && (server_handle[1] == (uint32_t)(-1))) ? NULL : server_handle, 0);
+                                   pixmap, ((server_handle[0] == 0) && (server_handle[1] == (uint32_t)(-1))) ? NULL : server_handle);
 
                      if (surface) {
                         if (khrn_pointer_map_insert(&process->surfaces, process->next_surface, surface)) {
@@ -2245,6 +2240,9 @@ EGLAPI EGLBoolean EGLAPIENTRY eglSwapBuffers(EGLDisplay dpy, EGLSurface surf)
    CLIENT_THREAD_STATE_T *thread;
    CLIENT_PROCESS_STATE_T *process;
    EGLBoolean result;
+#ifdef BUILD_WAYLAND
+   struct wl_display *wl_display = khrn_platform_get_wl_display();
+#endif
 
    vcos_log_trace("eglSwapBuffers start. dpy=%d. surf=%d.", (int)dpy, (int)surf);
 
@@ -2315,18 +2313,58 @@ EGLAPI EGLBoolean EGLAPIENTRY eglSwapBuffers(EGLDisplay dpy, EGLSurface surf)
 
                vcos_log_trace("eglSwapBuffers server call");
 
-               if (next_resource_handle)
-               RPC_CALL7(eglIntSwapBuffers_impl,
-                     thread,
-                     EGLINTSWAPBUFFERS_ID_V2,
-                     RPC_UINT(surface->serverbuffer),
-                     RPC_UINT(surface->width),
-                     RPC_UINT(surface->height),
-                     RPC_UINT(surface->internal_handle),
-                     RPC_UINT(surface->swap_behavior == EGL_BUFFER_PRESERVED ? 1 : 0),
-                     RPC_UINT(khrn_platform_get_window_position(surface->win)),
-                     RPC_INT(next_resource_handle));
-               else
+#ifdef BUILD_WAYLAND
+               if (wl_display) {
+                  struct wl_egl_window *wl_egl_window = surface->wl_egl_window;
+                  struct wl_dispmanx_client_buffer *buffer_temp;
+                  uint32_t configid;
+                  KHRN_IMAGE_FORMAT_T color;
+                  int ret = 0;
+
+                  buffer_temp = surface->front_wl_buffer;
+                  surface->front_wl_buffer = surface->back_wl_buffer;
+                  surface->back_wl_buffer = buffer_temp;
+
+                  configid = egl_config_to_id(surface->config);
+                  color = egl_config_get_color_format(configid);
+
+                  if (surface->back_wl_buffer == NULL)
+                     surface->back_wl_buffer = allocate_wl_buffer(wl_egl_window, color);
+                  else if (surface->back_wl_buffer->width != width ||
+                           surface->back_wl_buffer->height != height) {
+
+                     struct wl_dispmanx_client_buffer *buffer;
+
+                     wl_buffer_destroy(surface->back_wl_buffer->wl_buffer);
+                     free(surface->back_wl_buffer);
+
+                     buffer = allocate_wl_buffer(wl_egl_window, color);
+                     surface->back_wl_buffer = buffer;
+                  }
+
+                  RPC_CALL7(eglIntSwapBuffers_impl,
+                        thread,
+                        EGLINTSWAPBUFFERS_ID_V2,
+                        RPC_UINT(surface->serverbuffer),
+                        RPC_UINT(surface->width),
+                        RPC_UINT(surface->height),
+                        RPC_UINT(surface->internal_handle),
+                        RPC_UINT(surface->swap_behavior == EGL_BUFFER_PRESERVED ? 1 : 0),
+                        RPC_UINT(khrn_platform_get_window_position(surface->win)),
+                        RPC_INT(surface->back_wl_buffer->resource));
+
+                  surface->front_wl_buffer->in_use = 1;
+                  wl_surface_attach(wl_egl_window->wl_surface,
+                                    surface->front_wl_buffer->wl_buffer,
+                                    0, 0);
+                  wl_surface_damage(wl_egl_window->wl_surface, 0, 0,
+                                    surface->width, surface->height);
+                  wl_surface_commit(wl_egl_window->wl_surface);
+
+                  while(ret != -1 && surface->back_wl_buffer->in_use)
+                     ret = wl_display_dispatch_queue(wl_display, process->wl_queue);
+               } else
+#endif
                RPC_CALL6(eglIntSwapBuffers_impl,
                      thread,
                      EGLINTSWAPBUFFERS_ID,
diff --git a/interface/khronos/egl/egl_client_get_proc.c b/interface/khronos/egl/egl_client_get_proc.c
index 4cfa9ff..6a715af 100644
--- a/interface/khronos/egl/egl_client_get_proc.c
+++ b/interface/khronos/egl/egl_client_get_proc.c
@@ -254,6 +254,17 @@ EGLAPI void EGLAPIENTRY (* eglGetProcAddress(const char *procname))(void)
       return (void(*)(void))eglQueryGlobalImageBRCM;
 #endif
 
+#ifdef BUILD_WAYLAND
+#if EGL_WL_bind_wayland_display
+   if (!strcmp(procname, "eglBindWaylandDisplayWL"))
+      return (void(*)(void))eglBindWaylandDisplayWL;
+   if (!strcmp(procname, "eglUnbindWaylandDisplayWL"))
+      return (void(*)(void))eglUnbindWaylandDisplayWL;
+   if (!strcmp(procname, "eglQueryWaylandBufferWL"))
+      return (void(*)(void))eglQueryWaylandBufferWL;
+#endif
+#endif
+
    return (void(*)(void)) NULL;
 }
 
diff --git a/interface/khronos/egl/egl_client_surface.c b/interface/khronos/egl/egl_client_surface.c
index 128325e..42350bf 100644
--- a/interface/khronos/egl/egl_client_surface.c
+++ b/interface/khronos/egl/egl_client_surface.c
@@ -46,6 +46,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "interface/khronos/egl/egl_int_impl.h"
 #endif
 
+#ifdef BUILD_WAYLAND
+#include "interface/khronos/wayland-egl/wayland-egl-priv.h"
+#include "interface/khronos/common/linux/khrn_wayland.h"
+#endif
+
 #include <stdlib.h>
 
 
@@ -314,8 +319,7 @@ EGL_SURFACE_T *egl_surface_create(
    EGLenum texture_format,
    EGLenum texture_target,
    EGLNativePixmapType pixmap,
-   const uint32_t *pixmap_server_handle,
-   DISPMANX_RESOURCE_HANDLE_T next_resource_handle)
+   const uint32_t *pixmap_server_handle)
 {
    KHRN_IMAGE_FORMAT_T color;
    KHRN_IMAGE_FORMAT_T depth;
@@ -326,6 +330,10 @@ EGL_SURFACE_T *egl_surface_create(
    EGLint   config_depth_bits;
    EGLint   config_stencil_bits;
    CLIENT_THREAD_STATE_T *thread = CLIENT_GET_THREAD_STATE();
+#ifdef BUILD_WAYLAND
+   struct wl_display *wl_display = khrn_platform_get_wl_display();
+   DISPMANX_RESOURCE_HANDLE_T resource;
+#endif
 
    EGL_SURFACE_T *surface = egl_surface_pool_alloc();
 
@@ -390,6 +398,18 @@ EGL_SURFACE_T *egl_surface_create(
 
    vcos_assert(color != IMAGE_FORMAT_INVALID);
 
+#ifdef BUILD_WAYLAND
+   if (type == WINDOW && wl_display) {
+      surface->wl_egl_window = (struct wl_egl_window*)win;
+      surface->back_wl_buffer = allocate_wl_buffer(
+            surface->wl_egl_window, color);
+      resource = surface->back_wl_buffer->resource;
+   } else {
+      surface->wl_egl_window = NULL;
+      resource = DISPMANX_NO_HANDLE;
+   }
+#endif
+
 #ifdef KHRONOS_EGL_PLATFORM_OPENWFC
    // Create stream for this window
    if(type != PBUFFER)
@@ -474,7 +494,8 @@ EGL_SURFACE_T *egl_surface_create(
 #endif
          uint32_t results[3];
 
-         if (next_resource_handle)
+#ifdef BUILD_WAYLAND
+         if (resource != DISPMANX_NO_HANDLE)
          RPC_CALL16_OUT_CTRL(eglIntCreateSurface_impl,
                              thread,
                              EGLINTCREATESURFACE_ID_V2,
@@ -492,9 +513,10 @@ EGL_SURFACE_T *egl_surface_create(
                              RPC_UINT(config_stencil_bits),
                              RPC_UINT(sem_name),
                              RPC_UINT(type),
-                             RPC_INT(next_resource_handle),
+                             RPC_INT(resource),
                              results);
          else
+#endif
          RPC_CALL15_OUT_CTRL(eglIntCreateSurface_impl,
                              thread,
                              EGLINTCREATESURFACE_ID,
@@ -663,6 +685,18 @@ void egl_surface_free(EGL_SURFACE_T *surface)
    if( surface->type == WINDOW ) {
       vcos_log_trace("egl_surface_free: calling platform_destroy_winhandle...");
       platform_destroy_winhandle( surface->win, surface->internal_handle );
+
+#ifdef BUILD_WAYLAND
+      if (surface->back_wl_buffer) {
+         wl_buffer_destroy(surface->back_wl_buffer->wl_buffer);
+         free(surface->back_wl_buffer);
+      }
+
+      if (surface->front_wl_buffer) {
+         wl_buffer_destroy(surface->front_wl_buffer->wl_buffer);
+         free(surface->front_wl_buffer);
+      }
+#endif
    }
    /* return value ignored -- read performed to ensure blocking. we want this to
     * block so clients can safely destroy the surface's window as soon as the
diff --git a/interface/khronos/egl/egl_client_surface.h b/interface/khronos/egl/egl_client_surface.h
index b5bf70a..e328b77 100644
--- a/interface/khronos/egl/egl_client_surface.h
+++ b/interface/khronos/egl/egl_client_surface.h
@@ -288,6 +288,41 @@ typedef struct {
       type == PIXMAP
    */
    bool server_owned;
+
+#ifdef BUILD_WAYLAND
+   /*
+      wl_egl_window
+
+      Validity:
+      type == WINDOW
+
+      Invariant:
+      wayland EGL window
+   */
+   struct wl_egl_window *wl_egl_window;
+
+   /*
+      front_wl_buffer
+
+      Validity:
+      type == WINDOW
+
+      Invariant:
+      client-side information about the wl_buffer in the front
+   */
+   struct wl_dispmanx_client_buffer *front_wl_buffer;
+
+   /*
+      back_wl_buffer
+
+      Validity:
+      type == WINDOW
+
+      Invariant:
+      client-side information about the wl_buffer in the back
+   */
+   struct wl_dispmanx_client_buffer *back_wl_buffer;
+#endif
 } EGL_SURFACE_T;
 
 extern bool egl_surface_check_attribs(
@@ -322,8 +357,7 @@ extern EGL_SURFACE_T *egl_surface_create(
    EGLenum texture_format,
    EGLenum texture_target,
    EGLNativePixmapType pixmap,
-   const uint32_t *pixmap_server_handle,
-   DISPMANX_RESOURCE_HANDLE_T next_resource_handle);
+   const uint32_t *pixmap_server_handle);
 extern EGL_SURFACE_T *egl_surface_from_vg_image(
    VGImage vg_handle,
    EGLSurface name,
diff --git a/interface/khronos/egl/egl_int_impl.h b/interface/khronos/egl/egl_int_impl.h
index 51b3580..6863a3b 100644
--- a/interface/khronos/egl/egl_int_impl.h
+++ b/interface/khronos/egl/egl_int_impl.h
@@ -57,7 +57,7 @@ FN(int, eglIntCreateSurface_impl, (
    uint32_t sem,
    uint32_t type,
    uint32_t *results,
-   DISPMANX_RESOURCE_HANDLE_T next_resource_handle))
+   DISPMANX_RESOURCE_HANDLE_T resource_handle))
 
 FN(int, eglIntCreatePbufferFromVGImage_impl, (
    VGImage vg_handle,
diff --git a/interface/khronos/ext/egl_wayland.c b/interface/khronos/ext/egl_wayland.c
new file mode 100644
index 0000000..5730743
--- /dev/null
+++ b/interface/khronos/ext/egl_wayland.c
@@ -0,0 +1,247 @@
+/*
+Copyright (c) 2013, Raspberry Pi Foundation
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "interface/khronos/common/khrn_client_mangle.h"
+#include "interface/khronos/common/khrn_client_rpc.h"
+
+#include "interface/khronos/ext/egl_khr_sync_client.h"
+#include "interface/khronos/include/EGL/egl.h"
+#include "interface/khronos/include/EGL/eglext.h"
+
+#include "interface/vmcs_host/vc_vchi_dispmanx.h"
+
+#include <wayland-server.h>
+#include "interface/khronos/wayland-dispmanx-server-protocol.h"
+
+static void
+destroy_buffer(struct wl_resource *resource)
+{
+   struct wl_dispmanx_server_buffer *buffer = wl_resource_get_user_data(resource);
+
+   if(!buffer->in_use)
+      vc_dispmanx_resource_delete(buffer->handle);
+
+   free(buffer);
+}
+
+static void
+buffer_destroy(struct wl_client *client, struct wl_resource *resource)
+{
+   wl_resource_destroy(resource);
+}
+
+static const struct wl_buffer_interface dispmanx_buffer_interface = {
+   buffer_destroy
+};
+
+static VC_IMAGE_TYPE_T
+get_vc_format(enum wl_dispmanx_format format)
+{
+	/* XXX: The app is likely to have been premultiplying in its shaders,
+	 * but the VC scanout hardware on the RPi cannot mix premultiplied alpha
+	 * channel with the element's alpha.
+	 */
+	switch (format) {
+	case WL_DISPMANX_FORMAT_ABGR8888:
+		return VC_IMAGE_RGBA32;
+	case WL_DISPMANX_FORMAT_XBGR8888:
+		return VC_IMAGE_BGRX8888;
+	case WL_DISPMANX_FORMAT_RGB565:
+		return VC_IMAGE_RGB565;
+	default:
+		/* invalid format */
+		return VC_IMAGE_MIN;
+	}
+}
+
+static void
+dispmanx_create_buffer(struct wl_client *client, struct wl_resource *resource,
+                       uint32_t id, int32_t width, int32_t height,
+                       uint32_t stride, uint32_t buffer_height, uint32_t format)
+{
+   struct wl_dispmanx_server_buffer *buffer;
+   VC_IMAGE_TYPE_T vc_format = get_vc_format(format);
+   uint32_t dummy;
+
+   if(vc_format == VC_IMAGE_MIN) {
+      wl_resource_post_error(resource,
+                             WL_DISPMANX_ERROR_INVALID_FORMAT,
+                             "invalid format");
+      return;
+   }
+
+   buffer = calloc(1, sizeof *buffer);
+   if (buffer == NULL) {
+      wl_resource_post_no_memory(resource);
+      return;
+   }
+
+   buffer->handle = vc_dispmanx_resource_create(vc_format,
+                                                width | (stride << 16),
+                                                height | (buffer_height << 16),
+                                                &dummy);
+   if(buffer->handle == DISPMANX_NO_HANDLE) {
+      wl_resource_post_error(resource,
+                             WL_DISPMANX_ERROR_ALLOC_FAILED,
+                             "allocation failed");
+      free(buffer);
+      return;
+   }
+
+   buffer->width = width;
+   buffer->height = height;
+   buffer->format = format;
+
+   buffer->resource = wl_resource_create(resource->client, &wl_buffer_interface,
+                                         1, id);
+   if (!buffer->resource) {
+      wl_resource_post_no_memory(resource);
+      vc_dispmanx_resource_delete(buffer->handle);
+      free(buffer);
+      return;
+   }
+
+   wl_resource_set_implementation(buffer->resource,
+				       (void (**)(void)) &dispmanx_buffer_interface,
+				       buffer, destroy_buffer);
+
+   wl_dispmanx_send_buffer_allocated(resource, buffer->resource,
+                                     buffer->handle);
+}
+
+static const struct wl_dispmanx_interface dispmanx_interface = {
+   dispmanx_create_buffer,
+};
+
+static void
+bind_dispmanx(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+   struct wl_resource *resource;
+
+   resource = wl_resource_create(client, &wl_dispmanx_interface, 1, id);
+   wl_resource_set_implementation(resource, &dispmanx_interface, NULL, NULL);
+
+   wl_resource_post_event(resource, WL_DISPMANX_FORMAT,
+                          WL_DISPMANX_FORMAT_ARGB8888);
+
+   wl_resource_post_event(resource, WL_DISPMANX_FORMAT,
+                          WL_DISPMANX_FORMAT_XRGB8888);
+
+   wl_resource_post_event(resource, WL_DISPMANX_FORMAT,
+                          WL_DISPMANX_FORMAT_ABGR8888);
+
+   wl_resource_post_event(resource, WL_DISPMANX_FORMAT,
+                          WL_DISPMANX_FORMAT_XBGR8888);
+
+   wl_resource_post_event(resource, WL_DISPMANX_FORMAT,
+                          WL_DISPMANX_FORMAT_RGB565);
+}
+
+EGLBoolean EGLAPIENTRY
+eglBindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display)
+{
+   CLIENT_THREAD_STATE_T *thread;
+   CLIENT_PROCESS_STATE_T *process;
+
+   if (!CLIENT_LOCK_AND_GET_STATES(dpy, &thread, &process))
+      return EGL_FALSE;
+
+   if (process->wl_global != NULL)
+      goto error;
+
+   process->wl_global = wl_global_create(display, &wl_dispmanx_interface, 1,
+                                         NULL, bind_dispmanx);
+   if (process->wl_global == NULL)
+      goto error;
+
+   CLIENT_UNLOCK();
+   return EGL_TRUE;
+
+error:
+   CLIENT_UNLOCK();
+   return EGL_FALSE;
+}
+
+EGLBoolean EGLAPIENTRY
+eglUnbindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display)
+{
+   CLIENT_THREAD_STATE_T *thread;
+   CLIENT_PROCESS_STATE_T *process;
+
+   if (!CLIENT_LOCK_AND_GET_STATES(dpy, &thread, &process))
+      return EGL_FALSE;
+
+   wl_global_destroy(process->wl_global);
+   process->wl_global = NULL;
+
+   CLIENT_UNLOCK();
+
+   return EGL_TRUE;
+}
+
+static int
+get_egl_format(enum wl_dispmanx_format format)
+{
+	switch (format) {
+	case WL_DISPMANX_FORMAT_ABGR8888:
+		return EGL_TEXTURE_RGBA;
+	case WL_DISPMANX_FORMAT_XBGR8888:
+		return EGL_TEXTURE_RGB;
+	case WL_DISPMANX_FORMAT_RGB565:
+		return EGL_TEXTURE_RGB;
+	default:
+		/* invalid format */
+		return EGL_NO_TEXTURE;
+	}
+}
+
+EGLBoolean EGLAPIENTRY
+eglQueryWaylandBufferWL(EGLDisplay dpy, struct wl_resource *_buffer,
+         EGLint attribute, EGLint *value)
+{
+   struct wl_dispmanx_server_buffer *buffer = wl_resource_get_user_data(_buffer);
+
+   if (wl_resource_instance_of(_buffer, &wl_dispmanx_interface,
+                               &dispmanx_buffer_interface))
+      return EGL_FALSE;
+
+   switch (attribute) {
+   case EGL_TEXTURE_FORMAT:
+      *value = get_egl_format(buffer->format);
+      if (*value == EGL_NO_TEXTURE)
+         return EGL_FALSE;
+      return EGL_TRUE;
+   case EGL_WIDTH:
+      *value = buffer->width;
+      return EGL_TRUE;
+   case EGL_HEIGHT:
+      *value = buffer->height;
+      return EGL_TRUE;
+   }
+
+   return EGL_FALSE;
+}
diff --git a/interface/khronos/include/EGL/eglext.h b/interface/khronos/include/EGL/eglext.h
index 89a3369..d7e5ba7 100755
--- a/interface/khronos/include/EGL/eglext.h
+++ b/interface/khronos/include/EGL/eglext.h
@@ -191,6 +191,29 @@ typedef EGLBoolean (EGLAPIENTRYP PFNEGLGETSYNCATTRIBKHRPROC) (EGLDisplay dpy, EG
 #endif
 
 
+#ifndef EGL_WL_bind_wayland_display
+#define EGL_WL_bind_wayland_display 1
+
+#define EGL_WAYLAND_BUFFER_WL		0x31D5 /* eglCreateImageKHR target */
+#define EGL_WAYLAND_PLANE_WL		0x31D6 /* eglCreateImageKHR target */
+#define EGL_TEXTURE_Y_U_V_WL            0x31D7
+#define EGL_TEXTURE_Y_UV_WL             0x31D8
+#define EGL_TEXTURE_Y_XUXV_WL           0x31D9
+
+struct wl_display;
+struct wl_resource;
+#ifdef EGL_EGLEXT_PROTOTYPES
+EGLAPI EGLBoolean EGLAPIENTRY eglBindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display);
+EGLAPI EGLBoolean EGLAPIENTRY eglUnbindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display);
+EGLAPI EGLBoolean EGLAPIENTRY eglQueryWaylandBufferWL(EGLDisplay dpy, struct wl_resource *buffer, EGLint attribute, EGLint *value);
+#endif
+typedef EGLBoolean (EGLAPIENTRYP PFNEGLBINDWAYLANDDISPLAYWL) (EGLDisplay dpy, struct wl_display *display);
+typedef EGLBoolean (EGLAPIENTRYP PFNEGLUNBINDWAYLANDDISPLAYWL) (EGLDisplay dpy, struct wl_display *display);
+typedef EGLBoolean (EGLAPIENTRYP PFNEGLQUERYWAYLANDBUFFERWL) (EGLDisplay dpy, struct wl_resource *buffer, EGLint attribute, EGLint *value);
+
+#endif
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/interface/khronos/wayland-egl/wayland-egl-priv.h b/interface/khronos/wayland-egl/wayland-egl-priv.h
new file mode 100644
index 0000000..8e38d36
--- /dev/null
+++ b/interface/khronos/wayland-egl/wayland-egl-priv.h
@@ -0,0 +1,53 @@
+/* Copied from Mesa */
+
+#ifndef _WAYLAND_EGL_PRIV_H
+#define _WAYLAND_EGL_PRIV_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* GCC visibility */
+#if defined(__GNUC__) && __GNUC__ >= 4
+#define WL_EGL_EXPORT __attribute__ ((visibility("default")))
+#else
+#define WL_EGL_EXPORT
+#endif
+
+#include "interface/vmcs_host/vc_dispmanx.h"
+#include "interface/khronos/egl/egl_client_surface.h"
+
+#include <wayland-client.h>
+
+struct wl_dispmanx_client_buffer {
+	struct wl_buffer *wl_buffer;
+	DISPMANX_RESOURCE_HANDLE_T resource;
+
+	int pending_allocation;
+	int in_use;
+	int width;
+	int height;
+};
+
+struct wl_egl_window {
+	struct wl_surface *wl_surface;
+
+	int width;
+	int height;
+	int dx;
+	int dy;
+
+	int attached_width;
+	int attached_height;
+
+	/* XXX: The VC side seems to expect a valid element handle to be
+	   passed to eglIntCreateSurface_impl and/or eglIntSwapBuffers_impl,
+	   even for host-managed surfaces. */
+	DISPMANX_ELEMENT_HANDLE_T dummy_element;
+};
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/interface/khronos/wayland-egl/wayland-egl.c b/interface/khronos/wayland-egl/wayland-egl.c
new file mode 100644
index 0000000..b8f050b
--- /dev/null
+++ b/interface/khronos/wayland-egl/wayland-egl.c
@@ -0,0 +1,59 @@
+/* Copied from Mesa */
+
+#include <stdlib.h>
+
+#include <wayland-client.h>
+#include <wayland-egl.h>
+#include "wayland-egl-priv.h"
+
+WL_EGL_EXPORT void
+wl_egl_window_resize(struct wl_egl_window *egl_window,
+		     int width, int height,
+		     int dx, int dy)
+{
+        if (egl_window->width == width &&
+	    egl_window->height == height &&
+	    egl_window->dx == dx &&
+	    egl_window->dy == dy)
+		return;
+
+	egl_window->width = width;
+	egl_window->height = height;
+	egl_window->dx = dx;
+	egl_window->dy = dy;
+}
+
+WL_EGL_EXPORT struct wl_egl_window *
+wl_egl_window_create(struct wl_surface *surface,
+		     int width, int height)
+{
+	struct wl_egl_window *egl_window;
+
+	egl_window = calloc(1, sizeof *egl_window);
+	if (!egl_window)
+		return NULL;
+
+	egl_window->wl_surface = surface;
+	wl_egl_window_resize(egl_window, width, height, 0, 0);
+	egl_window->attached_width  = 0;
+	egl_window->attached_height = 0;
+	egl_window->dummy_element = PLATFORM_WIN_NONE;
+
+	return egl_window;
+}
+
+WL_EGL_EXPORT void
+wl_egl_window_destroy(struct wl_egl_window *egl_window)
+{
+	free(egl_window);
+}
+
+WL_EGL_EXPORT void
+wl_egl_window_get_attached_size(struct wl_egl_window *egl_window,
+				int *width, int *height)
+{
+	if (width)
+		*width = egl_window->attached_width;
+	if (height)
+		*height = egl_window->attached_height;
+}
diff --git a/interface/khronos/wayland-egl/wayland-egl.pc.in b/interface/khronos/wayland-egl/wayland-egl.pc.in
new file mode 100644
index 0000000..8bafc15
--- /dev/null
+++ b/interface/khronos/wayland-egl/wayland-egl.pc.in
@@ -0,0 +1,10 @@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=${prefix}
+libdir=${exec_prefix}/lib
+includedir=${prefix}/include
+
+Name: wayland-egl
+Description: VideoCore wayland-egl library
+Version: @PROJECT_APIVER@
+Libs: -L${libdir} -lwayland-egl
+Cflags: -I${includedir}
diff --git a/interface/vmcs_host/CMakeLists.txt b/interface/vmcs_host/CMakeLists.txt
index fde18da..6718215 100755
--- a/interface/vmcs_host/CMakeLists.txt
+++ b/interface/vmcs_host/CMakeLists.txt
@@ -9,13 +9,24 @@ add_definitions(-fno-strict-aliasing)
 
 include_directories(${VMCS_TARGET}/vcfiled)
 
-add_library(vchostif
-            ${VMCS_TARGET}/vcfilesys.c ${VMCS_TARGET}/vcmisc.c
-            vc_vchi_gencmd.c vc_vchi_filesys.c vc_vchi_gpuserv.c
-            vc_vchi_tvservice.c vc_vchi_cecservice.c
-            vc_vchi_dispmanx.c vc_service_common.c)
+set(VCHOSTIF_SOURCE
+    ${VMCS_TARGET}/vcfilesys.c ${VMCS_TARGET}/vcmisc.c
+    vc_vchi_gencmd.c vc_vchi_filesys.c vc_vchi_gpuserv.c
+    vc_vchi_tvservice.c vc_vchi_cecservice.c
+    vc_vchi_dispmanx.c vc_service_common.c)
 #            ${VMCS_TARGET}/vmcs_main.c
 #  vc_vchi_haud.c
+
+if (BUILD_WAYLAND)
+wayland_add_protocol_server(
+    VCHOSTIF_SOURCE
+    ../../interface/wayland/dispmanx.xml
+    dispmanx
+)
+endif ()
+
+add_library(vchostif ${VCHOSTIF_SOURCE})
+
 #add_library(bufman            vc_vchi_bufman.c            )
 
 # OpenMAX/IL component service
diff --git a/interface/vmcs_host/vc_dispmanx.h b/interface/vmcs_host/vc_dispmanx.h
index 37fdae1..fe3619a 100755
--- a/interface/vmcs_host/vc_dispmanx.h
+++ b/interface/vmcs_host/vc_dispmanx.h
@@ -39,6 +39,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifdef __cplusplus
 extern "C" {
 #endif
+
+#ifdef BUILD_WAYLAND
+struct wl_resource;
+#endif
+
 // Same function as above, to aid migration of code.
 VCHPRE_ int VCHPOST_ vc_dispman_init( void );
 // Stop the service from being used
@@ -135,6 +140,11 @@ VCHPRE_ int VCHPOST_ vc_dispmanx_resource_set_palette( DISPMANX_RESOURCE_HANDLE_
 // Start triggering callbacks synced to vsync
 VCHPRE_ int VCHPOST_ vc_dispmanx_vsync_callback( DISPMANX_DISPLAY_HANDLE_T display, DISPMANX_CALLBACK_FUNC_T cb_func, void *cb_arg );
 
+#ifdef BUILD_WAYLAND
+VCHPRE_ DISPMANX_RESOURCE_HANDLE_T VCHPOST_ vc_dispmanx_get_handle_from_wl_buffer( struct wl_resource *_buffer );
+
+VCHPRE_ void VCHPOST_ vc_dispmanx_set_wl_buffer_in_use( struct wl_resource *_buffer, int in_use );
+#endif
 #ifdef __cplusplus
 }
 #endif
diff --git a/interface/vmcs_host/vc_vchi_dispmanx.c b/interface/vmcs_host/vc_vchi_dispmanx.c
index 133e86d..45f4cff 100755
--- a/interface/vmcs_host/vc_vchi_dispmanx.c
+++ b/interface/vmcs_host/vc_vchi_dispmanx.c
@@ -1319,3 +1319,45 @@ static void *dispmanx_notify_func( void *arg ) {
    }
    return 0;
 }
+
+
+#ifdef BUILD_WAYLAND
+/***********************************************************
+ * Name: vc_dispmanx_get_handle_from_wl_buffer
+ *
+ * Arguments:
+ *       struct wl_resource *_buffer
+ *
+ * Description: Return the handle of the resource associated to this Wayland buffer
+ *
+ * Returns: A resource handle
+ *
+ ***********************************************************/
+VCHPRE_ DISPMANX_RESOURCE_HANDLE_T VCHPOST_ vc_dispmanx_get_handle_from_wl_buffer( struct wl_resource *_buffer )
+{
+	struct wl_dispmanx_server_buffer *buffer = (struct wl_dispmanx_server_buffer*)_buffer->data;
+	if (!buffer)
+		return DISPMANX_NO_HANDLE;
+
+	return buffer->handle;
+}
+
+/***********************************************************
+ * Name: vc_dispmanx_set_wl_buffer_in_use
+ *
+ * Arguments:
+ *       struct wl_resource *_buffer
+ *       int in_use
+ *
+ * Description: Mark this Wayland buffer as being in use by the compositor
+ *
+ ***********************************************************/
+VCHPRE_ void VCHPOST_ vc_dispmanx_set_wl_buffer_in_use( struct wl_resource *_buffer, int in_use )
+{
+	struct wl_dispmanx_server_buffer *buffer = (struct wl_dispmanx_server_buffer*)_buffer->data;
+	if (!buffer)
+		return;
+
+	buffer->in_use = in_use;
+}
+#endif
diff --git a/interface/vmcs_host/vc_vchi_dispmanx.h b/interface/vmcs_host/vc_vchi_dispmanx.h
index b723b76..f0bae30 100644
--- a/interface/vmcs_host/vc_vchi_dispmanx.h
+++ b/interface/vmcs_host/vc_vchi_dispmanx.h
@@ -66,4 +66,19 @@ typedef struct {
 #define ELEMENT_CHANGE_MASK_RESOURCE  (1<<4)
 #define ELEMENT_CHANGE_TRANSFORM      (1<<5)
 
+#ifdef BUILD_WAYLAND
+/* XXX: This should be in a private header that can be included from EGL and vc_* */
+#include <wayland-server.h>
+#include "interface/vmcs_host/wayland-dispmanx-server-protocol.h"
+struct wl_dispmanx_server_buffer {
+	struct wl_resource *resource;
+	struct wl_dispmanx *dispmanx;
+	enum wl_dispmanx_format format;
+	DISPMANX_RESOURCE_HANDLE_T handle;
+	int32_t width;
+	int32_t height;
+	int in_use;
+};
+#endif
+
 #endif
diff --git a/interface/wayland/dispmanx.xml b/interface/wayland/dispmanx.xml
new file mode 100644
index 0000000..c18626d
--- /dev/null
+++ b/interface/wayland/dispmanx.xml
@@ -0,0 +1,123 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="dispmanx">
+
+  <copyright>
+    Copyright  2008-2011 Kristian Hgsberg
+    Copyright  2010-2011 Intel Corporation
+    Copyright  2013 Raspberry Pi Foundation
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that\n the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <!-- DispManX support. This object is created by the server and published
+       using the display's global event. -->
+  <interface name="wl_dispmanx" version="1">
+    <enum name="error">
+      <entry name="alloc_failed" value="0"/>
+      <entry name="invalid_format" value="1"/>
+    </enum>
+
+    <enum name="format">
+      <!-- The pixel format codes match the #defines in drm_fourcc.h.
+           The formats actually supported by the compositor will be
+           reported by the format event. -->
+      <entry name="c8" value="0x20203843"/>
+      <entry name="rgb332" value="0x38424752"/>
+      <entry name="bgr233" value="0x38524742"/>
+      <entry name="xrgb4444" value="0x32315258"/>
+      <entry name="xbgr4444" value="0x32314258"/>
+      <entry name="rgbx4444" value="0x32315852"/>
+      <entry name="bgrx4444" value="0x32315842"/>
+      <entry name="argb4444" value="0x32315241"/>
+      <entry name="abgr4444" value="0x32314241"/>
+      <entry name="rgba4444" value="0x32314152"/>
+      <entry name="bgra4444" value="0x32314142"/>
+      <entry name="xrgb1555" value="0x35315258"/>
+      <entry name="xbgr1555" value="0x35314258"/>
+      <entry name="rgbx5551" value="0x35315852"/>
+      <entry name="bgrx5551" value="0x35315842"/>
+      <entry name="argb1555" value="0x35315241"/>
+      <entry name="abgr1555" value="0x35314241"/>
+      <entry name="rgba5551" value="0x35314152"/>
+      <entry name="bgra5551" value="0x35314142"/>
+      <entry name="rgb565" value="0x36314752"/>
+      <entry name="bgr565" value="0x36314742"/>
+      <entry name="rgb888" value="0x34324752"/>
+      <entry name="bgr888" value="0x34324742"/>
+      <entry name="xrgb8888" value="0x34325258"/>
+      <entry name="xbgr8888" value="0x34324258"/>
+      <entry name="rgbx8888" value="0x34325852"/>
+      <entry name="bgrx8888" value="0x34325842"/>
+      <entry name="argb8888" value="0x34325241"/>
+      <entry name="abgr8888" value="0x34324241"/>
+      <entry name="rgba8888" value="0x34324152"/>
+      <entry name="bgra8888" value="0x34324142"/>
+      <entry name="xrgb2101010" value="0x30335258"/>
+      <entry name="xbgr2101010" value="0x30334258"/>
+      <entry name="rgbx1010102" value="0x30335852"/>
+      <entry name="bgrx1010102" value="0x30335842"/>
+      <entry name="argb2101010" value="0x30335241"/>
+      <entry name="abgr2101010" value="0x30334241"/>
+      <entry name="rgba1010102" value="0x30334152"/>
+      <entry name="bgra1010102" value="0x30334142"/>
+      <entry name="yuyv" value="0x56595559"/>
+      <entry name="yvyu" value="0x55595659"/>
+      <entry name="uyvy" value="0x59565955"/>
+      <entry name="vyuy" value="0x59555956"/>
+      <entry name="ayuv" value="0x56555941"/>
+      <entry name="nv12" value="0x3231564e"/>
+      <entry name="nv21" value="0x3132564e"/>
+      <entry name="nv16" value="0x3631564e"/>
+      <entry name="nv61" value="0x3136564e"/>
+      <entry name="yuv410" value="0x39565559"/>
+      <entry name="yvu410" value="0x39555659"/>
+      <entry name="yuv411" value="0x31315559"/>
+      <entry name="yvu411" value="0x31315659"/>
+      <entry name="yuv420" value="0x32315559"/>
+      <entry name="yvu420" value="0x32315659"/>
+      <entry name="yuv422" value="0x36315559"/>
+      <entry name="yvu422" value="0x36315659"/>
+      <entry name="yuv444" value="0x34325559"/>
+      <entry name="yvu444" value="0x34325659"/>
+    </enum>
+
+    <event name="format">
+      <arg name="format" type="uint"/>
+    </event>
+
+    <!-- Create a wayland buffer for the DispManX resource. -->
+    <request name="create_buffer">
+      <arg name="id" type="new_id" interface="wl_buffer"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="stride" type="uint"/>
+      <arg name="buffer_height" type="uint"/>
+      <arg name="format" type="uint"/>
+    </request>
+
+    <event name="buffer_allocated">
+      <arg name="buffer" type="object" interface="wl_buffer"/>
+      <arg name="handle" type="uint"/>
+    </event>
+  </interface>
+
+</protocol>
diff --git a/makefiles/cmake/Wayland.cmake b/makefiles/cmake/Wayland.cmake
new file mode 100644
index 0000000..ad90d30
--- /dev/null
+++ b/makefiles/cmake/Wayland.cmake
@@ -0,0 +1,72 @@
+#=============================================================================
+# Copyright (C) 2012-2013 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# * Redistributions of source code must retain the above copyright
+#   notice, this list of conditions and the following disclaimer.
+#
+# * Redistributions in binary form must reproduce the above copyright
+#   notice, this list of conditions and the following disclaimer in the
+#   documentation and/or other materials provided with the distribution.
+#
+# * Neither the name of Pier Luigi Fiorini nor the names of his
+#   contributors may be used to endorse or promote products derived
+#   from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#=============================================================================
+
+find_program(WAYLAND_SCANNER_EXECUTABLE NAMES wayland-scanner)
+
+# wayland_add_protocol_client(outfiles inputfile basename)
+function(WAYLAND_ADD_PROTOCOL_CLIENT _sources _protocol _basename)
+    if(NOT WAYLAND_SCANNER_EXECUTABLE)
+        message(FATAL "The wayland-scanner executable has nto been found on your system. You must install it.")
+    endif()
+
+    get_filename_component(_infile ${_protocol} ABSOLUTE)
+    set(_client_header "${CMAKE_CURRENT_BINARY_DIR}/wayland-${_basename}-client-protocol.h")
+    set(_code "${CMAKE_CURRENT_BINARY_DIR}/wayland-${_basename}-protocol.c")
+
+    add_custom_command(OUTPUT "${_client_header}"
+        COMMAND ${WAYLAND_SCANNER_EXECUTABLE} client-header < ${_infile} > ${_client_header}
+        DEPENDS ${_infile} VERBATIM)
+
+    add_custom_command(OUTPUT "${_code}"
+        COMMAND ${WAYLAND_SCANNER_EXECUTABLE} code < ${_infile} > ${_code}
+        DEPENDS ${_infile} VERBATIM)
+
+    list(APPEND ${_sources} "${_client_header}" "${_code}")
+    set(${_sources} ${${_sources}} PARENT_SCOPE)
+endfunction()
+
+# wayland_add_protocol_server(outfiles inputfile basename)
+function(WAYLAND_ADD_PROTOCOL_SERVER _sources _protocol _basename)
+    if(NOT WAYLAND_SCANNER_EXECUTABLE)
+        message(FATAL "The wayland-scanner executable has nto been found on your system. You must install it.")
+    endif()
+
+    get_filename_component(_infile ${_protocol} ABSOLUTE)
+    set(_server_header "${CMAKE_CURRENT_BINARY_DIR}/wayland-${_basename}-server-protocol.h")
+
+    add_custom_command(OUTPUT "${_server_header}"
+        COMMAND ${WAYLAND_SCANNER_EXECUTABLE} server-header < ${_infile} > ${_server_header}
+        DEPENDS ${_infile} VERBATIM)
+
+    list(APPEND ${_sources} "${_server_header}")
+    set(${_sources} ${${_sources}} PARENT_SCOPE)
+endfunction()

From 08679675740d92f022e0fd46207a42589c9f6c51 Mon Sep 17 00:00:00 2001
From: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date: Tue, 1 Oct 2013 13:19:20 +0200
Subject: [PATCH 03/14] wayland: Add Wayland example

---
 .../linux/apps/hello_pi/CMakeLists.txt             |   1 +
 .../apps/hello_pi/hello_wayland/CMakeLists.txt     |   8 +
 .../apps/hello_pi/hello_wayland/Djenne_128_128.raw |   3 +
 .../linux/apps/hello_pi/hello_wayland/Makefile     |   5 +
 .../hello_wayland/cube_texture_and_coords.h        | 100 ++++
 .../linux/apps/hello_pi/hello_wayland/triangle.c   | 666 +++++++++++++++++++++
 host_applications/linux/apps/hello_pi/rebuild.sh   |   3 +-
 7 files changed, 785 insertions(+), 1 deletion(-)
 create mode 100644 host_applications/linux/apps/hello_pi/hello_wayland/CMakeLists.txt
 create mode 100644 host_applications/linux/apps/hello_pi/hello_wayland/Djenne_128_128.raw
 create mode 100644 host_applications/linux/apps/hello_pi/hello_wayland/Makefile
 create mode 100644 host_applications/linux/apps/hello_pi/hello_wayland/cube_texture_and_coords.h
 create mode 100644 host_applications/linux/apps/hello_pi/hello_wayland/triangle.c

diff --git a/host_applications/linux/apps/hello_pi/CMakeLists.txt b/host_applications/linux/apps/hello_pi/CMakeLists.txt
index f2c6aef..0df78f7 100644
--- a/host_applications/linux/apps/hello_pi/CMakeLists.txt
+++ b/host_applications/linux/apps/hello_pi/CMakeLists.txt
@@ -21,6 +21,7 @@ add_subdirectory(hello_encode)
 add_subdirectory(hello_jpeg)
 add_subdirectory(hello_videocube)
 add_subdirectory(hello_teapot)
+add_subdirectory(hello_wayland)
 
 if(BUILD_FONT)
 set(VGFONT_SRCS libs/vgfont/font.c libs/vgfont/vgft.c libs/vgfont/graphics.c)
diff --git a/host_applications/linux/apps/hello_pi/hello_wayland/CMakeLists.txt b/host_applications/linux/apps/hello_pi/hello_wayland/CMakeLists.txt
new file mode 100644
index 0000000..9a2f75c
--- /dev/null
+++ b/host_applications/linux/apps/hello_pi/hello_wayland/CMakeLists.txt
@@ -0,0 +1,8 @@
+set(EXEC hello_wayland.bin)
+set(SRCS triangle.c)
+
+add_executable(${EXEC} ${SRCS})
+target_link_libraries(${EXEC} ${HELLO_PI_LIBS} -lwayland-client -lwayland-egl)
+
+install(TARGETS ${EXEC}
+        RUNTIME DESTINATION bin)
diff --git a/host_applications/linux/apps/hello_pi/hello_wayland/Makefile b/host_applications/linux/apps/hello_pi/hello_wayland/Makefile
new file mode 100644
index 0000000..c9ddf23
--- /dev/null
+++ b/host_applications/linux/apps/hello_pi/hello_wayland/Makefile
@@ -0,0 +1,5 @@
+OBJS=triangle.o
+BIN=hello_wayland.bin
+LDFLAGS+=-lwayland-client -lwayland-egl
+
+include ../Makefile.include
diff --git a/host_applications/linux/apps/hello_pi/hello_wayland/cube_texture_and_coords.h b/host_applications/linux/apps/hello_pi/hello_wayland/cube_texture_and_coords.h
new file mode 100644
index 0000000..663e23b
--- /dev/null
+++ b/host_applications/linux/apps/hello_pi/hello_wayland/cube_texture_and_coords.h
@@ -0,0 +1,100 @@
+/*
+Copyright (c) 2012, Broadcom Europe Ltd
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+// Spatial coordinates for the cube
+
+static const GLbyte quadx[6*4*3] = {
+   /* FRONT */
+   -10, -10,  10,
+   10, -10,  10,
+   -10,  10,  10,
+   10,  10,  10,
+
+   /* BACK */
+   -10, -10, -10,
+   -10,  10, -10,
+   10, -10, -10,
+   10,  10, -10,
+
+   /* LEFT */
+   -10, -10,  10,
+   -10,  10,  10,
+   -10, -10, -10,
+   -10,  10, -10,
+
+   /* RIGHT */
+   10, -10, -10,
+   10,  10, -10,
+   10, -10,  10,
+   10,  10,  10,
+
+   /* TOP */
+   -10,  10,  10,
+   10,  10,  10,
+   -10,  10, -10,
+   10,  10, -10,
+
+   /* BOTTOM */
+   -10, -10,  10,
+   -10, -10, -10,
+   10, -10,  10,
+   10, -10, -10,
+};
+
+/** Texture coordinates for the quad. */
+static const GLfloat texCoords[6 * 4 * 2] = {
+   0.f,  0.f,
+   1.f,  0.f,
+   0.f,  1.f,
+   1.f,  1.f,
+
+   0.f,  0.f,
+   1.f,  0.f,
+   0.f,  1.f,
+   1.f,  1.f,
+
+   0.f,  0.f,
+   1.f,  0.f,
+   0.f,  1.f,
+   1.f,  1.f,
+
+   0.f,  0.f,
+   1.f,  0.f,
+   0.f,  1.f,
+   1.f,  1.f,
+
+   0.f,  0.f,
+   1.f,  0.f,
+   0.f,  1.f,
+   1.f,  1.f,
+
+   0.f,  0.f,
+   1.f,  0.f,
+   0.f,  1.f,
+   1.f,  1.f,
+};
+
diff --git a/host_applications/linux/apps/hello_pi/hello_wayland/triangle.c b/host_applications/linux/apps/hello_pi/hello_wayland/triangle.c
new file mode 100644
index 0000000..1a7bfc4
--- /dev/null
+++ b/host_applications/linux/apps/hello_pi/hello_wayland/triangle.c
@@ -0,0 +1,666 @@
+/*
+Copyright (c) 2012, Broadcom Europe Ltd
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+// A rotating cube rendered with OpenGL|ES. Three images used as textures on the cube faces.
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <assert.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#include <wayland-egl.h>
+#include <wayland-client.h>
+
+#include "GLES/gl.h"
+#include "EGL/egl.h"
+#include "EGL/eglext.h"
+
+#include "cube_texture_and_coords.h"
+
+#define PATH "./"
+
+#define IMAGE_SIZE 128
+
+#ifndef M_PI
+   #define M_PI 3.141592654
+#endif
+	
+
+typedef struct
+{
+   uint32_t screen_width;
+   uint32_t screen_height;
+// OpenGL|ES objects
+   EGLDisplay display;
+   EGLSurface surface;
+   EGLContext context;
+   GLuint tex[6];
+// model rotation vector and direction
+   GLfloat rot_angle_x_inc;
+   GLfloat rot_angle_y_inc;
+   GLfloat rot_angle_z_inc;
+// current model rotation angles
+   GLfloat rot_angle_x;
+   GLfloat rot_angle_y;
+   GLfloat rot_angle_z;
+// current distance from camera
+   GLfloat distance;
+   GLfloat distance_inc;
+// pointers to texture buffers
+   char *tex_buf1;
+   char *tex_buf2;
+   char *tex_buf3;
+   struct wl_display *wl_display;
+   struct wl_registry *wl_registry;
+   struct wl_shell *wl_shell;
+   struct wl_shell_surface *wl_shell_surface;
+   struct wl_compositor *wl_compositor;
+   struct wl_surface *wl_surface;
+   struct wl_callback *wl_callback;
+   struct wl_egl_window *wl_egl_window;
+   int needs_update;
+   int ellapsed_frames;
+   int kill_compositor;
+   int single_frame;
+   int terminate_abruptly;
+} CUBE_STATE_T;
+
+static void init_ogl(CUBE_STATE_T *state);
+static void init_model_proj(CUBE_STATE_T *state);
+static void reset_model(CUBE_STATE_T *state);
+static GLfloat inc_and_wrap_angle(GLfloat angle, GLfloat angle_inc);
+static GLfloat inc_and_clip_distance(GLfloat distance, GLfloat distance_inc);
+static void redraw_scene(CUBE_STATE_T *state);
+static void update_model(CUBE_STATE_T *state);
+static void init_textures(CUBE_STATE_T *state);
+static void load_tex_images(CUBE_STATE_T *state);
+static void exit_func(CUBE_STATE_T *state);
+
+static void
+registry_handle_global(void *data, struct wl_registry *registry,
+		       uint32_t name, const char *interface, uint32_t version)
+{
+	CUBE_STATE_T *state = data;
+
+	if (strcmp(interface, "wl_compositor") == 0) {
+		state->wl_compositor =
+			wl_registry_bind(registry, name,
+					 &wl_compositor_interface, 1);
+	} else if (strcmp(interface, "wl_shell") == 0) {
+		state->wl_shell = wl_registry_bind(registry, name,
+					    &wl_shell_interface, 1);
+	}
+}
+
+static void
+registry_handle_global_remove(void *data, struct wl_registry *registry,
+			      uint32_t name)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global,
+	registry_handle_global_remove
+};
+
+/***********************************************************
+ * Name: init_ogl
+ *
+ * Arguments:
+ *       CUBE_STATE_T *state - holds OGLES model info
+ *
+ * Description: Sets the display, OpenGL|ES context and screen stuff
+ *
+ * Returns: void
+ *
+ ***********************************************************/
+static void init_ogl(CUBE_STATE_T *state)
+{
+   EGLBoolean result;
+   EGLint num_config;
+
+   static const EGLint attribute_list[] =
+   {
+      EGL_RED_SIZE, 8,
+      EGL_GREEN_SIZE, 8,
+      EGL_BLUE_SIZE, 8,
+      EGL_ALPHA_SIZE, 8,
+      EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+      EGL_NONE
+   };
+   
+   EGLConfig config;
+
+   state->wl_display = wl_display_connect(NULL);
+
+   state->wl_registry = wl_display_get_registry(state->wl_display);
+   wl_registry_add_listener(state->wl_registry, &registry_listener, state);
+
+   wl_display_dispatch(state->wl_display);
+
+   // get an EGL display connection
+   state->display = eglGetDisplay(state->wl_display);
+   assert(state->display!=EGL_NO_DISPLAY);
+
+   // initialize the EGL display connection
+   result = eglInitialize(state->display, NULL, NULL);
+   assert(EGL_FALSE != result);
+
+   // get an appropriate EGL frame buffer configuration
+   result = eglChooseConfig(state->display, attribute_list, &config, 1, &num_config);
+   assert(EGL_FALSE != result);
+
+   // create an EGL rendering context
+   state->context = eglCreateContext(state->display, config, EGL_NO_CONTEXT, NULL);
+   assert(state->context!=EGL_NO_CONTEXT);
+
+   // create an EGL window surface
+   state->screen_width = 1024;
+   state->screen_height = 860;
+
+   state->wl_surface = wl_compositor_create_surface(state->wl_compositor);
+   state->wl_shell_surface = wl_shell_get_shell_surface(state->wl_shell, state->wl_surface);
+
+   wl_shell_surface_set_toplevel(state->wl_shell_surface);
+   wl_shell_surface_set_title(state->wl_shell_surface, "triangle.c");
+
+   state->wl_egl_window = wl_egl_window_create(state->wl_surface, state->screen_width, state->screen_height);
+
+   state->surface = eglCreateWindowSurface( state->display, config, state->wl_egl_window, NULL );
+   assert(state->surface != EGL_NO_SURFACE);
+
+   // connect the context to the surface
+   result = eglMakeCurrent(state->display, state->surface, state->surface, state->context);
+   assert(EGL_FALSE != result);
+
+   // Set background color and clear buffers
+   glClearColor(0.15f, 0.25f, 0.35f, 1.0f);
+
+   // Enable back face culling.
+   glEnable(GL_CULL_FACE);
+
+   glMatrixMode(GL_MODELVIEW);
+}
+
+/***********************************************************
+ * Name: init_model_proj
+ *
+ * Arguments:
+ *       CUBE_STATE_T *state - holds OGLES model info
+ *
+ * Description: Sets the OpenGL|ES model to default values
+ *
+ * Returns: void
+ *
+ ***********************************************************/
+static void init_model_proj(CUBE_STATE_T *state)
+{
+   float nearp = 1.0f;
+   float farp = 500.0f;
+   float hht;
+   float hwd;
+
+   glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
+
+   glViewport(0, 0, (GLsizei)state->screen_width, (GLsizei)state->screen_height);
+      
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+
+   hht = nearp * (float)tan(45.0 / 2.0 / 180.0 * M_PI);
+   hwd = hht * (float)state->screen_width / (float)state->screen_height;
+
+   glFrustumf(-hwd, hwd, -hht, hht, nearp, farp);
+   
+   glEnableClientState( GL_VERTEX_ARRAY );
+   glVertexPointer( 3, GL_BYTE, 0, quadx );
+
+   reset_model(state);
+}
+
+/***********************************************************
+ * Name: reset_model
+ *
+ * Arguments:
+ *       CUBE_STATE_T *state - holds OGLES model info
+ *
+ * Description: Resets the Model projection and rotation direction
+ *
+ * Returns: void
+ *
+ ***********************************************************/
+static void reset_model(CUBE_STATE_T *state)
+{
+   // reset model position
+   glMatrixMode(GL_MODELVIEW);
+   glLoadIdentity();
+   glTranslatef(0.f, 0.f, -50.f);
+
+   // reset model rotation
+   state->rot_angle_x = 45.f; state->rot_angle_y = 30.f; state->rot_angle_z = 0.f;
+   state->rot_angle_x_inc = 0.5f; state->rot_angle_y_inc = 0.5f; state->rot_angle_z_inc = 0.f;
+   state->distance = 40.f;
+}
+
+/***********************************************************
+ * Name: update_model
+ *
+ * Arguments:
+ *       CUBE_STATE_T *state - holds OGLES model info
+ *
+ * Description: Updates model projection to current position/rotation
+ *
+ * Returns: void
+ *
+ ***********************************************************/
+static void update_model(CUBE_STATE_T *state)
+{
+   // update position
+   state->rot_angle_x = inc_and_wrap_angle(state->rot_angle_x, state->rot_angle_x_inc);
+   state->rot_angle_y = inc_and_wrap_angle(state->rot_angle_y, state->rot_angle_y_inc);
+   state->rot_angle_z = inc_and_wrap_angle(state->rot_angle_z, state->rot_angle_z_inc);
+   state->distance    = inc_and_clip_distance(state->distance, state->distance_inc);
+
+   glLoadIdentity();
+   // move camera back to see the cube
+   glTranslatef(0.f, 0.f, -state->distance);
+
+   // Rotate model to new position
+   glRotatef(state->rot_angle_x, 1.f, 0.f, 0.f);
+   glRotatef(state->rot_angle_y, 0.f, 1.f, 0.f);
+   glRotatef(state->rot_angle_z, 0.f, 0.f, 1.f);
+}
+
+/***********************************************************
+ * Name: inc_and_wrap_angle
+ *
+ * Arguments:
+ *       GLfloat angle     current angle
+ *       GLfloat angle_inc angle increment
+ *
+ * Description:   Increments or decrements angle by angle_inc degrees
+ *                Wraps to 0 at 360 deg.
+ *
+ * Returns: new value of angle
+ *
+ ***********************************************************/
+static GLfloat inc_and_wrap_angle(GLfloat angle, GLfloat angle_inc)
+{
+   angle += angle_inc;
+
+   if (angle >= 360.0)
+      angle -= 360.f;
+   else if (angle <=0)
+      angle += 360.f;
+
+   return angle;
+}
+
+/***********************************************************
+ * Name: inc_and_clip_distance
+ *
+ * Arguments:
+ *       GLfloat distance     current distance
+ *       GLfloat distance_inc distance increment
+ *
+ * Description:   Increments or decrements distance by distance_inc units
+ *                Clips to range
+ *
+ * Returns: new value of angle
+ *
+ ***********************************************************/
+static GLfloat inc_and_clip_distance(GLfloat distance, GLfloat distance_inc)
+{
+   distance += distance_inc;
+
+   if (distance >= 120.0f)
+      distance = 120.f;
+   else if (distance <= 40.0f)
+      distance = 40.0f;
+
+   return distance;
+}
+
+static pid_t get_server_pid(CUBE_STATE_T *state)
+{
+   struct ucred ucred;
+   socklen_t len;
+   int fd;
+
+   fd = wl_display_get_fd(state->wl_display);
+   len = sizeof ucred;
+   getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &ucred, &len);
+
+   return ucred.pid;
+}
+
+static void
+frame(void *data, struct wl_callback *callback, uint32_t time)
+{
+   CUBE_STATE_T *state = (CUBE_STATE_T *) data;
+
+   state->needs_update = 1;
+}
+
+static const struct wl_callback_listener frame_listener = {
+	frame
+};
+
+static void
+update(CUBE_STATE_T *state)
+{
+   if (!state->single_frame || state->ellapsed_frames == 0) {
+      update_model(state);
+      redraw_scene(state);
+   }
+
+   state->wl_callback = wl_surface_frame(state->wl_surface);
+   wl_callback_add_listener(state->wl_callback, &frame_listener, state);
+
+   if (state->ellapsed_frames == 100) {
+      if (state->kill_compositor) {
+         fprintf(stderr, "reached frame 100, killing compositor\n");
+         pid_t pid = get_server_pid(state);
+         kill(pid, SIGTERM);
+      } else if (state->terminate_abruptly) {
+         fprintf(stderr, "reached frame 100, terminating right away\n");
+         exit_func(state);
+         exit(0);
+      }
+   }
+
+   if (!state->single_frame || state->ellapsed_frames == 0)
+      eglSwapBuffers(state->display, state->surface);
+   else {
+      wl_surface_damage(state->wl_surface, 0, 0, state->screen_width,
+                        state->screen_height);
+      wl_surface_commit(state->wl_surface);
+   }
+
+   state->ellapsed_frames++;
+}
+
+/***********************************************************
+ * Name: redraw_scene
+ *
+ * Arguments:
+ *       CUBE_STATE_T *state - holds OGLES model info
+ *
+ * Description:   Draws the model and calls eglSwapBuffers
+ *                to render to screen
+ *
+ * Returns: void
+ *
+ ***********************************************************/
+static void redraw_scene(CUBE_STATE_T *state)
+{
+   // Start with a clear screen
+   glClear( GL_COLOR_BUFFER_BIT );
+
+   // Draw first (front) face:
+   // Bind texture surface to current vertices
+   glBindTexture(GL_TEXTURE_2D, state->tex[0]);
+
+   // Need to rotate textures - do this by rotating each cube face
+   glRotatef(270.f, 0.f, 0.f, 1.f ); // front face normal along z axis
+
+   // draw first 4 vertices
+   glDrawArrays( GL_TRIANGLE_STRIP, 0, 4);
+
+   // same pattern for other 5 faces - rotation chosen to make image orientation 'nice'
+   glBindTexture(GL_TEXTURE_2D, state->tex[1]);
+   glRotatef(90.f, 0.f, 0.f, 1.f ); // back face normal along z axis
+   glDrawArrays( GL_TRIANGLE_STRIP, 4, 4);
+
+   glBindTexture(GL_TEXTURE_2D, state->tex[2]);
+   glRotatef(90.f, 1.f, 0.f, 0.f ); // left face normal along x axis
+   glDrawArrays( GL_TRIANGLE_STRIP, 8, 4);
+
+   glBindTexture(GL_TEXTURE_2D, state->tex[3]);
+   glRotatef(90.f, 1.f, 0.f, 0.f ); // right face normal along x axis
+   glDrawArrays( GL_TRIANGLE_STRIP, 12, 4);
+
+   glBindTexture(GL_TEXTURE_2D, state->tex[4]);
+   glRotatef(270.f, 0.f, 1.f, 0.f ); // top face normal along y axis
+   glDrawArrays( GL_TRIANGLE_STRIP, 16, 4);
+
+   glBindTexture(GL_TEXTURE_2D, state->tex[5]);
+   glRotatef(90.f, 0.f, 1.f, 0.f ); // bottom face normal along y axis
+   glDrawArrays( GL_TRIANGLE_STRIP, 20, 4);
+}
+
+/***********************************************************
+ * Name: init_textures
+ *
+ * Arguments:
+ *       CUBE_STATE_T *state - holds OGLES model info
+ *
+ * Description:   Initialise OGL|ES texture surfaces to use image
+ *                buffers
+ *
+ * Returns: void
+ *
+ ***********************************************************/
+static void init_textures(CUBE_STATE_T *state)
+{
+   // load three texture buffers but use them on six OGL|ES texture surfaces
+   load_tex_images(state);
+   glGenTextures(6, &state->tex[0]);
+
+   // setup first texture
+   glBindTexture(GL_TEXTURE_2D, state->tex[0]);
+   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, IMAGE_SIZE, IMAGE_SIZE, 0,
+                GL_RGB, GL_UNSIGNED_BYTE, state->tex_buf1);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, (GLfloat)GL_NEAREST);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLfloat)GL_NEAREST);
+
+   // setup second texture - reuse first image
+   glBindTexture(GL_TEXTURE_2D, state->tex[1]);
+   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, IMAGE_SIZE, IMAGE_SIZE, 0,
+                GL_RGB, GL_UNSIGNED_BYTE, state->tex_buf1);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, (GLfloat)GL_NEAREST);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLfloat)GL_NEAREST);
+
+   // third texture
+   glBindTexture(GL_TEXTURE_2D, state->tex[2]);
+   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, IMAGE_SIZE, IMAGE_SIZE, 0,
+                GL_RGB, GL_UNSIGNED_BYTE, state->tex_buf2);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, (GLfloat)GL_NEAREST);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLfloat)GL_NEAREST);
+
+   // fourth texture  - reuse second image
+   glBindTexture(GL_TEXTURE_2D, state->tex[3]);
+   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, IMAGE_SIZE, IMAGE_SIZE, 0,
+                GL_RGB, GL_UNSIGNED_BYTE, state->tex_buf2);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, (GLfloat)GL_NEAREST);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLfloat)GL_NEAREST);
+
+   //fifth texture
+   glBindTexture(GL_TEXTURE_2D, state->tex[4]);
+   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, IMAGE_SIZE, IMAGE_SIZE, 0,
+                GL_RGB, GL_UNSIGNED_BYTE, state->tex_buf3);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, (GLfloat)GL_NEAREST);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLfloat)GL_NEAREST);
+
+   // sixth texture  - reuse third image
+   glBindTexture(GL_TEXTURE_2D, state->tex[5]);
+   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, IMAGE_SIZE, IMAGE_SIZE, 0,
+                GL_RGB, GL_UNSIGNED_BYTE, state->tex_buf3);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, (GLfloat)GL_NEAREST);
+   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLfloat)GL_NEAREST);
+
+   // setup overall texture environment
+   glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
+   glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+   
+   glEnable(GL_TEXTURE_2D);
+}
+
+/***********************************************************
+ * Name: load_tex_images
+ *
+ * Arguments:
+ *       void
+ *
+ * Description: Loads three raw images to use as textures on faces
+ *
+ * Returns: void
+ *
+ ***********************************************************/
+static void load_tex_images(CUBE_STATE_T *state)
+{
+   FILE *tex_file1 = NULL, *tex_file2=NULL, *tex_file3 = NULL;
+   int bytes_read, image_sz = IMAGE_SIZE*IMAGE_SIZE*3;
+
+   state->tex_buf1 = malloc(image_sz);
+   state->tex_buf2 = malloc(image_sz);
+   state->tex_buf3 = malloc(image_sz);
+
+   tex_file1 = fopen(PATH "Lucca_128_128.raw", "rb");
+   if (tex_file1 && state->tex_buf1)
+   {
+      bytes_read=fread(state->tex_buf1, 1, image_sz, tex_file1);
+      assert(bytes_read == image_sz);  // some problem with file?
+      fclose(tex_file1);
+   }
+
+   tex_file2 = fopen(PATH "Djenne_128_128.raw", "rb");
+   if (tex_file2 && state->tex_buf2)
+   {
+      bytes_read=fread(state->tex_buf2, 1, image_sz, tex_file2);
+      assert(bytes_read == image_sz);  // some problem with file?
+      fclose(tex_file2);      
+   }
+
+   tex_file3 = fopen(PATH "Gaudi_128_128.raw", "rb");
+   if (tex_file3 && state->tex_buf3)
+   {
+      bytes_read=fread(state->tex_buf3, 1, image_sz, tex_file3);
+      assert(bytes_read == image_sz);  // some problem with file?
+      fclose(tex_file3);
+   }   
+}
+
+//------------------------------------------------------------------------------
+
+static void exit_func(CUBE_STATE_T *state)
+{
+   // clear screen
+   glClear( GL_COLOR_BUFFER_BIT );
+   eglSwapBuffers(state->display, state->surface);
+
+   // Release OpenGL resources
+   eglMakeCurrent( state->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT );
+
+   wl_egl_window_destroy(state->wl_egl_window);
+   wl_shell_surface_destroy(state->wl_shell_surface);
+   wl_surface_destroy(state->wl_surface);
+
+   eglDestroySurface( state->display, state->surface );
+   eglDestroyContext( state->display, state->context );
+   eglTerminate( state->display );
+
+   wl_display_flush(state->wl_display);
+
+   // release texture buffers
+   free(state->tex_buf1);
+   free(state->tex_buf2);
+   free(state->tex_buf3);
+
+   printf("\ncube closed\n");
+} // exit_func()
+
+static int running = 1;
+
+static void
+signal_int(int signum)
+{
+	running = 0;
+}
+
+//==============================================================================
+
+int main (int argc, char *argv[])
+{
+   struct sigaction sigint;
+   CUBE_STATE_T state = {0,};
+   int ret = 0;
+   int i;
+
+   for (i = 0; i < argc; i++) {
+      if (strcmp(argv[i], "--kill-compositor") == 0)
+         state.kill_compositor = 1;
+      if (strcmp(argv[i], "--single-frame") == 0)
+         state.single_frame = 1;
+      if (strcmp(argv[i], "--terminate-abruptly") == 0)
+         state.terminate_abruptly = 1;
+      else if (strcmp(argv[i], "--help") == 0 ||
+               strcmp(argv[i], "-h") == 0) {
+         printf("Usage: hello_wayland.bin [OPTION]\n\n");
+         printf("\t--kill-compositor\tkill the Wayland compositor after 100 frames\n");
+         printf("\t-h, --help\t\tshow this text\n");
+         printf("\t--single-frame\t\tupdate the display only once\n");
+         printf("\t--terminate-abruptly\texit right after rendering the 100th frame\n");
+         return 0;
+      }
+   }
+
+   // Start OGLES
+   init_ogl(&state);
+
+   // Setup the model world
+   init_model_proj(&state);
+
+   // initialise the OGLES texture(s)
+   init_textures(&state);
+
+   sigint.sa_handler = signal_int;
+   sigemptyset(&sigint.sa_mask);
+   sigint.sa_flags = SA_RESETHAND;
+   sigaction(SIGINT, &sigint, NULL);
+
+   state.needs_update = 1;
+   while (running && ret != -1) {
+      if (state.needs_update) {
+         update(&state);
+         state.needs_update = 0;
+      }
+
+      ret = wl_display_dispatch(state.wl_display);
+   }
+
+   exit_func(&state);
+
+   return 0;
+}
+
diff --git a/host_applications/linux/apps/hello_pi/rebuild.sh b/host_applications/linux/apps/hello_pi/rebuild.sh
index 8225dd5..0be6ce7 100755
--- a/host_applications/linux/apps/hello_pi/rebuild.sh
+++ b/host_applications/linux/apps/hello_pi/rebuild.sh
@@ -14,6 +14,7 @@ make -C hello_videocube clean
 make -C hello_teapot clean
 make -C hello_fft clean
 make -C hello_mmal_encode clean
+make -C hello_wayland clean
 
 make -C libs/ilclient
 make -C libs/vgfont
@@ -31,4 +32,4 @@ make -C hello_videocube
 make -C hello_teapot
 make -C hello_fft
 make -C hello_mmal_encode
-
+make -C hello_wayland

From eb9d0eb386b9b3df519a299887b45962c03e732c Mon Sep 17 00:00:00 2001
From: Khem Raj <raj.khem@gmail.com>
Date: Mon, 10 Aug 2015 02:38:27 -0700
Subject: [PATCH 04/14] wayland-egl: Add bcm_host to dependencies

It uses headers like vcos_platform_types.h but does not
depend on module which should add the required include paths
lets add the dependency on bcm_host module which should do it

Signed-off-by: Khem Raj <raj.khem@gmail.com>
---
 interface/khronos/wayland-egl/wayland-egl.pc.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/interface/khronos/wayland-egl/wayland-egl.pc.in b/interface/khronos/wayland-egl/wayland-egl.pc.in
index 8bafc15..fd259c9 100644
--- a/interface/khronos/wayland-egl/wayland-egl.pc.in
+++ b/interface/khronos/wayland-egl/wayland-egl.pc.in
@@ -6,5 +6,6 @@ includedir=${prefix}/include
 Name: wayland-egl
 Description: VideoCore wayland-egl library
 Version: @PROJECT_APIVER@
+Requires: bcm_host
 Libs: -L${libdir} -lwayland-egl
 Cflags: -I${includedir}

From ef3162e061a3231fbf836208f98c38c7c5581a9e Mon Sep 17 00:00:00 2001
From: "Yann E. MORIN" <yann.morin.1998@free.fr>
Date: Sat, 24 Jan 2015 22:07:19 +0100
Subject: [PATCH 05/14] interface: remove faulty assert() to make weston happy
 at runtime

This was removed after a discussion on IRC with the weston guys
('daniels' on irc.freenode.net/#wayland).

Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
---
 interface/vmcs_host/vc_vchi_dispmanx.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/interface/vmcs_host/vc_vchi_dispmanx.c b/interface/vmcs_host/vc_vchi_dispmanx.c
index 45f4cff..5d0368c 100755
--- a/interface/vmcs_host/vc_vchi_dispmanx.c
+++ b/interface/vmcs_host/vc_vchi_dispmanx.c
@@ -1306,7 +1306,6 @@ static void *dispmanx_notify_func( void *arg ) {
             // Decrement the use count - the corresponding "use" is in vc_dispmanx_update_submit.
             vchi_service_release(dispmanx_client.notify_handle[0]);
             if (dispmanx_client.update_callback ) {
-               vcos_assert( dispmanx_client.pending_update_handle == handle);
                dispmanx_client.update_callback(handle, dispmanx_client.update_callback_param);
             }
          } else {

From 846e9271cf6a264e7e1f4e33be64df990ff39a74 Mon Sep 17 00:00:00 2001
From: Khem Raj <raj.khem@gmail.com>
Date: Sat, 6 Feb 2016 11:10:47 -0800
Subject: [PATCH 06/14] zero-out wl buffers in egl_surface_free

origins from buildroot

Signed-off-by: Khem Raj <raj.khem@gmail.com>
---
 interface/khronos/egl/egl_client_surface.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/interface/khronos/egl/egl_client_surface.c b/interface/khronos/egl/egl_client_surface.c
index 42350bf..1f923d9 100644
--- a/interface/khronos/egl/egl_client_surface.c
+++ b/interface/khronos/egl/egl_client_surface.c
@@ -690,11 +690,13 @@ void egl_surface_free(EGL_SURFACE_T *surface)
       if (surface->back_wl_buffer) {
          wl_buffer_destroy(surface->back_wl_buffer->wl_buffer);
          free(surface->back_wl_buffer);
+         surface->back_wl_buffer = 0;
       }
 
       if (surface->front_wl_buffer) {
          wl_buffer_destroy(surface->front_wl_buffer->wl_buffer);
          free(surface->front_wl_buffer);
+         surface->front_wl_buffer = 0;
       }
 #endif
    }

From 15510fdf1c753c967b509046616b1e1a11b5b772 Mon Sep 17 00:00:00 2001
From: Khem Raj <raj.khem@gmail.com>
Date: Sat, 6 Feb 2016 11:11:41 -0800
Subject: [PATCH 07/14] initialize front back wayland buffers

origins from metrological wayland support

Signed-off-by: Khem Raj <raj.khem@gmail.com>
---
 interface/khronos/egl/egl_client_surface.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/interface/khronos/egl/egl_client_surface.c b/interface/khronos/egl/egl_client_surface.c
index 1f923d9..9a9582c 100644
--- a/interface/khronos/egl/egl_client_surface.c
+++ b/interface/khronos/egl/egl_client_surface.c
@@ -401,11 +401,14 @@ EGL_SURFACE_T *egl_surface_create(
 #ifdef BUILD_WAYLAND
    if (type == WINDOW && wl_display) {
       surface->wl_egl_window = (struct wl_egl_window*)win;
+      surface->front_wl_buffer = NULL;
       surface->back_wl_buffer = allocate_wl_buffer(
             surface->wl_egl_window, color);
       resource = surface->back_wl_buffer->resource;
    } else {
       surface->wl_egl_window = NULL;
+      surface->front_wl_buffer = NULL;
+      surface->back_wl_buffer = NULL;
       resource = DISPMANX_NO_HANDLE;
    }
 #endif

From 1df080ab9528b82321cf87d71927314294ef7121 Mon Sep 17 00:00:00 2001
From: Khem Raj <raj.khem@gmail.com>
Date: Sat, 6 Feb 2016 11:09:18 -0800
Subject: [PATCH 08/14] Remove RPC_FLUSH

Origins from buildroot

Signed-off-by: Khem Raj <raj.khem@gmail.com>
---
 interface/khronos/ext/gl_oes_egl_image_client.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/interface/khronos/ext/gl_oes_egl_image_client.c b/interface/khronos/ext/gl_oes_egl_image_client.c
index f9b7287..b04ffef 100644
--- a/interface/khronos/ext/gl_oes_egl_image_client.c
+++ b/interface/khronos/ext/gl_oes_egl_image_client.c
@@ -107,7 +107,6 @@ GL_API void GL_APIENTRY glEGLImageTargetTexture2DOES (GLenum target, GLeglImageO
                    GLEGLIMAGETARGETTEXTURE2DOES_ID,
                    RPC_ENUM(target),
                    RPC_EGLID(image));
-         RPC_FLUSH(thread);
 #if EGL_BRCM_global_image
       }
 #endif

From 11842307cc0e32bac6ef7622e7791ca7a0e9fa61 Mon Sep 17 00:00:00 2001
From: Khem Raj <raj.khem@gmail.com>
Date: Sat, 6 Feb 2016 13:12:47 -0800
Subject: [PATCH 09/14] fix cmake dependency race

Fixes errors like

/a/builder/mnt/build-oe/tmp-glibc/work/raspberrypi2-oe-linux-gnueabi/userland/git-r5/git/interface/vmcs_host/vc_vchi_dispmanx.h:72:66:
fatal error: interface/vmcs_host/wayland-dispmanx-server-protocol.h: No
such file or directory
compilation terminated.
interface/khronos/CMakeFiles/EGL_static.dir/build.make:773: recipe for
target 'interface/khronos/CMakeFiles/EGL_static.dir/ext/egl_wayland.c.o'
failed
make[2]: ***
[interface/khronos/CMakeFiles/EGL_static.dir/ext/egl_wayland.c.o] Error 1

Signed-off-by: Khem Raj <raj.khem@gmail.com>
---
 interface/vcos/pthreads/CMakeLists.txt | 8 ++++++++
 interface/vmcs_host/CMakeLists.txt     | 8 --------
 interface/vmcs_host/vc_vchi_dispmanx.h | 2 +-
 3 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/interface/vcos/pthreads/CMakeLists.txt b/interface/vcos/pthreads/CMakeLists.txt
index 1d81ca3..d6cd415 100644
--- a/interface/vcos/pthreads/CMakeLists.txt
+++ b/interface/vcos/pthreads/CMakeLists.txt
@@ -33,6 +33,14 @@ set (SOURCES
    ../generic/vcos_generic_blockpool.c
 )
 
+if (BUILD_WAYLAND)
+wayland_add_protocol_server(
+    SOURCES
+    ../../../interface/wayland/dispmanx.xml
+    dispmanx
+)
+endif ()
+
 if (VCOS_PTHREADS_BUILD_SHARED)
    add_library (vcos SHARED ${SOURCES})
    target_link_libraries (vcos pthread dl rt)
diff --git a/interface/vmcs_host/CMakeLists.txt b/interface/vmcs_host/CMakeLists.txt
index 6718215..c415176 100755
--- a/interface/vmcs_host/CMakeLists.txt
+++ b/interface/vmcs_host/CMakeLists.txt
@@ -17,14 +17,6 @@ set(VCHOSTIF_SOURCE
 #            ${VMCS_TARGET}/vmcs_main.c
 #  vc_vchi_haud.c
 
-if (BUILD_WAYLAND)
-wayland_add_protocol_server(
-    VCHOSTIF_SOURCE
-    ../../interface/wayland/dispmanx.xml
-    dispmanx
-)
-endif ()
-
 add_library(vchostif ${VCHOSTIF_SOURCE})
 
 #add_library(bufman            vc_vchi_bufman.c            )
diff --git a/interface/vmcs_host/vc_vchi_dispmanx.h b/interface/vmcs_host/vc_vchi_dispmanx.h
index f0bae30..8c44c58 100644
--- a/interface/vmcs_host/vc_vchi_dispmanx.h
+++ b/interface/vmcs_host/vc_vchi_dispmanx.h
@@ -69,7 +69,7 @@ typedef struct {
 #ifdef BUILD_WAYLAND
 /* XXX: This should be in a private header that can be included from EGL and vc_* */
 #include <wayland-server.h>
-#include "interface/vmcs_host/wayland-dispmanx-server-protocol.h"
+#include "interface/vcos/pthreads/wayland-dispmanx-server-protocol.h"
 struct wl_dispmanx_server_buffer {
 	struct wl_resource *resource;
 	struct wl_dispmanx *dispmanx;

From 532dc7dc11877a9dae0f3d101c9bfdacc50840ca Mon Sep 17 00:00:00 2001
From: Khem Raj <raj.khem@gmail.com>
Date: Tue, 29 Mar 2016 20:38:30 -0700
Subject: [PATCH 10/14] Fix for framerate with nested composition

frame rate appears irregular and lower than expected when using nested composition.

Signed-off-by: Khem Raj <raj.khem@gmail.com>
---
 interface/khronos/egl/egl_client.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/interface/khronos/egl/egl_client.c b/interface/khronos/egl/egl_client.c
index 03fe67b..13a110c 100644
--- a/interface/khronos/egl/egl_client.c
+++ b/interface/khronos/egl/egl_client.c
@@ -2342,6 +2342,9 @@ EGLAPI EGLBoolean EGLAPIENTRY eglSwapBuffers(EGLDisplay dpy, EGLSurface surf)
                      surface->back_wl_buffer = buffer;
                   }
 
+                  glFlush();
+                  glFinish();
+
                   RPC_CALL7(eglIntSwapBuffers_impl,
                         thread,
                         EGLINTSWAPBUFFERS_ID_V2,
@@ -2353,6 +2356,8 @@ EGLAPI EGLBoolean EGLAPIENTRY eglSwapBuffers(EGLDisplay dpy, EGLSurface surf)
                         RPC_UINT(khrn_platform_get_window_position(surface->win)),
                         RPC_INT(surface->back_wl_buffer->resource));
 
+                  RPC_FLUSH(thread);
+
                   surface->front_wl_buffer->in_use = 1;
                   wl_surface_attach(wl_egl_window->wl_surface,
                                     surface->front_wl_buffer->wl_buffer,
@@ -2360,11 +2365,13 @@ EGLAPI EGLBoolean EGLAPIENTRY eglSwapBuffers(EGLDisplay dpy, EGLSurface surf)
                   wl_surface_damage(wl_egl_window->wl_surface, 0, 0,
                                     surface->width, surface->height);
                   wl_surface_commit(wl_egl_window->wl_surface);
+                  wl_display_flush(wl_display);
 
                   while(ret != -1 && surface->back_wl_buffer->in_use)
                      ret = wl_display_dispatch_queue(wl_display, process->wl_queue);
                } else
 #endif
+               {
                RPC_CALL6(eglIntSwapBuffers_impl,
                      thread,
                      EGLINTSWAPBUFFERS_ID,
@@ -2376,6 +2383,7 @@ EGLAPI EGLBoolean EGLAPIENTRY eglSwapBuffers(EGLDisplay dpy, EGLSurface surf)
                      RPC_UINT(khrn_platform_get_window_position(surface->win)));
 
                RPC_FLUSH(thread);
+               }
 
 #ifdef ANDROID
                CLIENT_UNLOCK();

From 37ff90075102407d3abb3899b8c6ef64f6230207 Mon Sep 17 00:00:00 2001
From: Khem Raj <raj.khem@gmail.com>
Date: Sat, 2 Apr 2016 10:37:24 -0700
Subject: [PATCH 11/14] build shared library for vchostif

Fixes #149

Signed-off-by: Khem Raj <raj.khem@gmail.com>
---
 interface/vmcs_host/CMakeLists.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/interface/vmcs_host/CMakeLists.txt b/interface/vmcs_host/CMakeLists.txt
index c415176..d0cca1a 100755
--- a/interface/vmcs_host/CMakeLists.txt
+++ b/interface/vmcs_host/CMakeLists.txt
@@ -17,7 +17,7 @@ set(VCHOSTIF_SOURCE
 #            ${VMCS_TARGET}/vmcs_main.c
 #  vc_vchi_haud.c
 
-add_library(vchostif ${VCHOSTIF_SOURCE})
+add_library(vchostif SHARED ${VCHOSTIF_SOURCE})
 
 #add_library(bufman            vc_vchi_bufman.c            )
 

From ce130bff946c3b78fc4dbbf98d9b16b5152f2e85 Mon Sep 17 00:00:00 2001
From: Khem Raj <raj.khem@gmail.com>
Date: Sat, 2 Apr 2016 10:54:59 -0700
Subject: [PATCH 12/14] implement buffer wrapping interface for dispmanx

Courtesy: Zan Dobersek

Signed-off-by: Khem Raj <raj.khem@gmail.com>
---
 interface/khronos/ext/egl_wayland.c | 42 +++++++++++++++++++++++++++++++++++++
 interface/wayland/dispmanx.xml      | 10 +++++++++
 2 files changed, 52 insertions(+)

diff --git a/interface/khronos/ext/egl_wayland.c b/interface/khronos/ext/egl_wayland.c
index 5730743..9ef89cd 100644
--- a/interface/khronos/ext/egl_wayland.c
+++ b/interface/khronos/ext/egl_wayland.c
@@ -133,8 +133,50 @@ dispmanx_create_buffer(struct wl_client *client, struct wl_resource *resource,
                                      buffer->handle);
 }
 
+static void
+dispmanx_wrap_buffer(struct wl_client *client, struct wl_resource *resource,
+                     uint32_t id, uint32_t handle, int32_t width, int32_t height,
+                     uint32_t stride, uint32_t buffer_height, uint32_t format)
+{
+   struct wl_dispmanx_server_buffer *buffer;
+   VC_IMAGE_TYPE_T vc_format = get_vc_format(format);
+   uint32_t dummy;
+
+   if(vc_format == VC_IMAGE_MIN) {
+      wl_resource_post_error(resource,
+                             WL_DISPMANX_ERROR_INVALID_FORMAT,
+                             "invalid format");
+      return;
+   }
+
+   buffer = calloc(1, sizeof *buffer);
+   if (buffer == NULL) {
+      wl_resource_post_no_memory(resource);
+      return;
+   }
+
+   buffer->handle = handle;
+   buffer->width = width;
+   buffer->height = height;
+   buffer->format = format;
+
+   buffer->resource = wl_resource_create(resource->client, &wl_buffer_interface,
+                                         1, id);
+   if (!buffer->resource) {
+      wl_resource_post_no_memory(resource);
+      vc_dispmanx_resource_delete(buffer->handle);
+      free(buffer);
+      return;
+   }
+
+   wl_resource_set_implementation(buffer->resource,
+				       (void (**)(void)) &dispmanx_buffer_interface,
+				       buffer, destroy_buffer);
+}
+
 static const struct wl_dispmanx_interface dispmanx_interface = {
    dispmanx_create_buffer,
+   dispmanx_wrap_buffer,
 };
 
 static void
diff --git a/interface/wayland/dispmanx.xml b/interface/wayland/dispmanx.xml
index c18626d..11ed1ef 100644
--- a/interface/wayland/dispmanx.xml
+++ b/interface/wayland/dispmanx.xml
@@ -118,6 +118,16 @@
       <arg name="buffer" type="object" interface="wl_buffer"/>
       <arg name="handle" type="uint"/>
     </event>
+
+    <request name="wrap_buffer">
+      <arg name="id" type="new_id" interface="wl_buffer"/>
+      <arg name="handle" type="uint"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="stride" type="uint"/>
+      <arg name="buffer_height" type="uint"/>
+      <arg name="format" type="uint"/>
+    </request>
   </interface>
 
 </protocol>

From 14d915a63a4e69290966543ce12edd615bfa9a25 Mon Sep 17 00:00:00 2001
From: Jeff Wannamaker <jeff_wannamaker@cable.comcast.com>
Date: Thu, 19 Jan 2017 18:56:07 +0000
Subject: [PATCH 13/14] Implement triple buffering for wayland

Change from double to triple buffering for wayland.
This enables higher frame rates without tearing artifacts
by allowing both the glFinish and the buffer release
interlock to operate without pushing the frame period
to two vertical intervals

Signed-off-by: Jeff Wannamaker <jeff_wannamaker@cable.comcast.com>
Signed-off-by: Khem Raj <raj.khem@gmail.com>
---
 interface/khronos/egl/egl_client.c         |  3 ++-
 interface/khronos/egl/egl_client_surface.c |  8 ++++++++
 interface/khronos/egl/egl_client_surface.h | 11 +++++++++++
 3 files changed, 21 insertions(+), 1 deletion(-)

diff --git a/interface/khronos/egl/egl_client.c b/interface/khronos/egl/egl_client.c
index 13a110c..0380274 100644
--- a/interface/khronos/egl/egl_client.c
+++ b/interface/khronos/egl/egl_client.c
@@ -2323,7 +2323,8 @@ EGLAPI EGLBoolean EGLAPIENTRY eglSwapBuffers(EGLDisplay dpy, EGLSurface surf)
 
                   buffer_temp = surface->front_wl_buffer;
                   surface->front_wl_buffer = surface->back_wl_buffer;
-                  surface->back_wl_buffer = buffer_temp;
+                  surface->back_wl_buffer = surface->middle_wl_buffer;
+                  surface->middle_wl_buffer = buffer_temp;
 
                   configid = egl_config_to_id(surface->config);
                   color = egl_config_get_color_format(configid);
diff --git a/interface/khronos/egl/egl_client_surface.c b/interface/khronos/egl/egl_client_surface.c
index 9a9582c..10b3b04 100644
--- a/interface/khronos/egl/egl_client_surface.c
+++ b/interface/khronos/egl/egl_client_surface.c
@@ -402,12 +402,14 @@ EGL_SURFACE_T *egl_surface_create(
    if (type == WINDOW && wl_display) {
       surface->wl_egl_window = (struct wl_egl_window*)win;
       surface->front_wl_buffer = NULL;
+      surface->middle_wl_buffer = NULL;
       surface->back_wl_buffer = allocate_wl_buffer(
             surface->wl_egl_window, color);
       resource = surface->back_wl_buffer->resource;
    } else {
       surface->wl_egl_window = NULL;
       surface->front_wl_buffer = NULL;
+      surface->middle_wl_buffer = NULL;
       surface->back_wl_buffer = NULL;
       resource = DISPMANX_NO_HANDLE;
    }
@@ -696,6 +698,12 @@ void egl_surface_free(EGL_SURFACE_T *surface)
          surface->back_wl_buffer = 0;
       }
 
+      if (surface->middle_wl_buffer) {
+         wl_buffer_destroy(surface->middle_wl_buffer->wl_buffer);
+         free(surface->middle_wl_buffer);
+         surface->middle_wl_buffer = 0;
+      }
+
       if (surface->front_wl_buffer) {
          wl_buffer_destroy(surface->front_wl_buffer->wl_buffer);
          free(surface->front_wl_buffer);
diff --git a/interface/khronos/egl/egl_client_surface.h b/interface/khronos/egl/egl_client_surface.h
index e328b77..58a3184 100644
--- a/interface/khronos/egl/egl_client_surface.h
+++ b/interface/khronos/egl/egl_client_surface.h
@@ -313,6 +313,17 @@ typedef struct {
    struct wl_dispmanx_client_buffer *front_wl_buffer;
 
    /*
+      middle_wl_buffer
+
+      Validity:
+      type == WINDOW
+
+      Invariant:
+      client-side information about the wl_buffer in the middle
+   */
+   struct wl_dispmanx_client_buffer *middle_wl_buffer;
+
+   /*
       back_wl_buffer
 
       Validity:

